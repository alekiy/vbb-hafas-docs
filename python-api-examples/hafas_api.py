#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Thu Nov 29 22:00:28 2012 by generateDS.py version 2.7c.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class ReqC(GeneratedsSuper):
    """The element ReqC is the root element for requests to the HAFAS
    system. It must contain either a location vlidation request, a
    connection request or a connection scroll request. (See the
    corresponding elements for more details)."""
    subclass = None
    superclass = None
    def __init__(self, accessId=None, STBReq=None, ConReq=None, ConScrReq=None):
        self.accessId = _cast(None, accessId)
        self.STBReq = STBReq
        self.ConReq = ConReq
        self.ConScrReq = ConScrReq
    def factory(*args_, **kwargs_):
        if ReqC.subclass:
            return ReqC.subclass(*args_, **kwargs_)
        else:
            return ReqC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STBReq(self): return self.STBReq
    def set_STBReq(self, STBReq): self.STBReq = STBReq
    def get_ConReq(self): return self.ConReq
    def set_ConReq(self, ConReq): self.ConReq = ConReq
    def get_ConScrReq(self): return self.ConScrReq
    def set_ConScrReq(self, ConScrReq): self.ConScrReq = ConScrReq
    def get_accessId(self): return self.accessId
    def set_accessId(self, accessId): self.accessId = accessId
    def export(self, outfile, level, namespace_='', name_='ReqC', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReqC')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReqC'):
        if self.accessId is not None and 'accessId' not in already_processed:
            already_processed.append('accessId')
            outfile.write(' accessId=%s' % (self.gds_format_string(quote_attrib(self.accessId).encode(ExternalEncoding), input_name='accessId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReqC', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STBReq is not None:
            self.STBReq.export(outfile, level, namespace_, name_='STBReq', pretty_print=pretty_print)
        if self.ConReq is not None:
            self.ConReq.export(outfile, level, namespace_, name_='ConReq', pretty_print=pretty_print)
        if self.ConScrReq is not None:
            self.ConScrReq.export(outfile, level, namespace_, name_='ConScrReq', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.STBReq is not None or
            self.ConReq is not None or
            self.ConScrReq is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReqC'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.accessId is not None and 'accessId' not in already_processed:
            already_processed.append('accessId')
            showIndent(outfile, level)
            outfile.write('accessId = "%s",\n' % (self.accessId,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.STBReq is not None:
            showIndent(outfile, level)
            outfile.write('STBReq=model_.STBReq(\n')
            self.STBReq.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConReq is not None:
            showIndent(outfile, level)
            outfile.write('ConReq=model_.ConReq(\n')
            self.ConReq.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConScrReq is not None:
            showIndent(outfile, level)
            outfile.write('ConScrReq=model_.ConScrReq(\n')
            self.ConScrReq.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accessId', node)
        if value is not None and 'accessId' not in already_processed:
            already_processed.append('accessId')
            self.accessId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STBReq':
            obj_ = STBReq.factory()
            obj_.build(child_)
            self.set_STBReq(obj_)
        elif nodeName_ == 'ConReq':
            obj_ = ConReq.factory()
            obj_.build(child_)
            self.set_ConReq(obj_)
        elif nodeName_ == 'ConScrReq':
            obj_ = ConScrReq.factory()
            obj_.build(child_)
            self.set_ConScrReq(obj_)
# end class ReqC


class Err(GeneratedsSuper):
    """If an error occurs, the element Err indicates the type of the error
    and a descriptive text. This text is meant to be used for
    logging purposes or other internal use. Normally this message
    should not be presented to the user."""
    subclass = None
    superclass = None
    def __init__(self, text=None, code=None, level='E'):
        self.text = _cast(None, text)
        self.code = _cast(None, code)
        self.level = _cast(None, level)
        pass
    def factory(*args_, **kwargs_):
        if Err.subclass:
            return Err.subclass(*args_, **kwargs_)
        else:
            return Err(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def export(self, outfile, level, namespace_='', name_='Err', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Err')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Err'):
        if self.text is not None and 'text' not in already_processed:
            already_processed.append('text')
            outfile.write(' text=%s' % (self.gds_format_string(quote_attrib(self.text).encode(ExternalEncoding), input_name='text'), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (self.gds_format_string(quote_attrib(self.level).encode(ExternalEncoding), input_name='level'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Err', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Err'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.text is not None and 'text' not in already_processed:
            already_processed.append('text')
            showIndent(outfile, level)
            outfile.write('text = "%s",\n' % (self.text,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            showIndent(outfile, level)
            outfile.write('code = "%s",\n' % (self.code,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = "%s",\n' % (self.level,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.append('text')
            self.text = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.append('code')
            self.code = value
            self.code = ' '.join(self.code.split())
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
            self.level = ' '.join(self.level.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Err


class ConBasicReq(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ivCons='no', oevCons='yes', Start=None, Dest=None, Via=None, extensiontype_=None):
        self.ivCons = _cast(None, ivCons)
        self.oevCons = _cast(None, oevCons)
        self.Start = Start
        self.Dest = Dest
        if Via is None:
            self.Via = []
        else:
            self.Via = Via
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ConBasicReq.subclass:
            return ConBasicReq.subclass(*args_, **kwargs_)
        else:
            return ConBasicReq(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Start(self): return self.Start
    def set_Start(self, Start): self.Start = Start
    def get_Dest(self): return self.Dest
    def set_Dest(self, Dest): self.Dest = Dest
    def get_Via(self): return self.Via
    def set_Via(self, Via): self.Via = Via
    def add_Via(self, value): self.Via.append(value)
    def insert_Via(self, index, value): self.Via[index] = value
    def get_ivCons(self): return self.ivCons
    def set_ivCons(self, ivCons): self.ivCons = ivCons
    def get_oevCons(self): return self.oevCons
    def set_oevCons(self, oevCons): self.oevCons = oevCons
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='ConBasicReq', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConBasicReq')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConBasicReq'):
        if self.ivCons is not None and 'ivCons' not in already_processed:
            already_processed.append('ivCons')
            outfile.write(' ivCons=%s' % (self.gds_format_string(quote_attrib(self.ivCons).encode(ExternalEncoding), input_name='ivCons'), ))
        if self.oevCons is not None and 'oevCons' not in already_processed:
            already_processed.append('oevCons')
            outfile.write(' oevCons=%s' % (self.gds_format_string(quote_attrib(self.oevCons).encode(ExternalEncoding), input_name='oevCons'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ConBasicReq', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Start is not None:
            self.Start.export(outfile, level, namespace_, name_='Start', pretty_print=pretty_print)
        if self.Dest is not None:
            self.Dest.export(outfile, level, namespace_, name_='Dest', pretty_print=pretty_print)
        for Via_ in self.Via:
            Via_.export(outfile, level, namespace_, name_='Via', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Start is not None or
            self.Dest is not None or
            self.Via
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConBasicReq'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ivCons is not None and 'ivCons' not in already_processed:
            already_processed.append('ivCons')
            showIndent(outfile, level)
            outfile.write('ivCons = "%s",\n' % (self.ivCons,))
        if self.oevCons is not None and 'oevCons' not in already_processed:
            already_processed.append('oevCons')
            showIndent(outfile, level)
            outfile.write('oevCons = "%s",\n' % (self.oevCons,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Start is not None:
            showIndent(outfile, level)
            outfile.write('Start=model_.Start(\n')
            self.Start.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dest is not None:
            showIndent(outfile, level)
            outfile.write('Dest=model_.Dest(\n')
            self.Dest.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Via=[\n')
        level += 1
        for Via_ in self.Via:
            showIndent(outfile, level)
            outfile.write('model_.Via(\n')
            Via_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ivCons', node)
        if value is not None and 'ivCons' not in already_processed:
            already_processed.append('ivCons')
            self.ivCons = value
            self.ivCons = ' '.join(self.ivCons.split())
        value = find_attr_value_('oevCons', node)
        if value is not None and 'oevCons' not in already_processed:
            already_processed.append('oevCons')
            self.oevCons = value
            self.oevCons = ' '.join(self.oevCons.split())
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Start':
            obj_ = StartViaType.factory()
            obj_.build(child_)
            self.set_Start(obj_)
        elif nodeName_ == 'Dest':
            class_obj_ = self.get_class_obj_(child_, RequestLocationType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Dest(obj_)
        elif nodeName_ == 'Via':
            obj_ = ViaType.factory()
            obj_.build(child_)
            self.Via.append(obj_)
# end class ConBasicReq


class ConReq(ConBasicReq):
    """The element ConReq specifies an initial connection request (opposed
    to the element ConScrReq, that specifies a subsequent scroll
    request based on this initial request)."""
    subclass = None
    superclass = ConBasicReq
    def __init__(self, ivCons='no', oevCons='yes', Start=None, Dest=None, Via=None, ReqT=None, RFlags=None, GISParameters=None):
        super(ConReq, self).__init__(ivCons, oevCons, Start, Dest, Via, )
        self.ReqT = ReqT
        self.RFlags = RFlags
        self.GISParameters = GISParameters
    def factory(*args_, **kwargs_):
        if ConReq.subclass:
            return ConReq.subclass(*args_, **kwargs_)
        else:
            return ConReq(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReqT(self): return self.ReqT
    def set_ReqT(self, ReqT): self.ReqT = ReqT
    def get_RFlags(self): return self.RFlags
    def set_RFlags(self, RFlags): self.RFlags = RFlags
    def get_GISParameters(self): return self.GISParameters
    def set_GISParameters(self, GISParameters): self.GISParameters = GISParameters
    def export(self, outfile, level, namespace_='', name_='ConReq', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConReq')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConReq'):
        super(ConReq, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConReq')
    def exportChildren(self, outfile, level, namespace_='', name_='ConReq', fromsubclass_=False, pretty_print=True):
        super(ConReq, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReqT is not None:
            self.ReqT.export(outfile, level, namespace_, name_='ReqT', pretty_print=pretty_print)
        if self.RFlags is not None:
            self.RFlags.export(outfile, level, namespace_, name_='RFlags', pretty_print=pretty_print)
        if self.GISParameters is not None:
            self.GISParameters.export(outfile, level, namespace_, name_='GISParameters', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ReqT is not None or
            self.RFlags is not None or
            self.GISParameters is not None or
            super(ConReq, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConReq'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ConReq, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConReq, self).exportLiteralChildren(outfile, level, name_)
        if self.ReqT is not None:
            showIndent(outfile, level)
            outfile.write('ReqT=model_.ReqT(\n')
            self.ReqT.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RFlags is not None:
            showIndent(outfile, level)
            outfile.write('RFlags=model_.RFlags(\n')
            self.RFlags.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GISParameters is not None:
            showIndent(outfile, level)
            outfile.write('GISParameters=model_.GISParameters(\n')
            self.GISParameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ConReq, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReqT':
            obj_ = ReqTType.factory()
            obj_.build(child_)
            self.set_ReqT(obj_)
        elif nodeName_ == 'RFlags':
            obj_ = RFlags.factory()
            obj_.build(child_)
            self.set_RFlags(obj_)
        elif nodeName_ == 'GISParameters':
            obj_ = GISParameters.factory()
            obj_.build(child_)
            self.set_GISParameters(obj_)
        super(ConReq, self).buildChildren(child_, node, nodeName_, True)
# end class ConReq


class GISParameters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Front=None, Back=None, Total=None):
        self.Front = Front
        self.Back = Back
        self.Total = Total
    def factory(*args_, **kwargs_):
        if GISParameters.subclass:
            return GISParameters.subclass(*args_, **kwargs_)
        else:
            return GISParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Front(self): return self.Front
    def set_Front(self, Front): self.Front = Front
    def get_Back(self): return self.Back
    def set_Back(self, Back): self.Back = Back
    def get_Total(self): return self.Total
    def set_Total(self, Total): self.Total = Total
    def export(self, outfile, level, namespace_='', name_='GISParameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GISParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GISParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GISParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Front is not None:
            self.Front.export(outfile, level, namespace_, name_='Front', pretty_print=pretty_print)
        if self.Back is not None:
            self.Back.export(outfile, level, namespace_, name_='Back', pretty_print=pretty_print)
        if self.Total is not None:
            self.Total.export(outfile, level, namespace_, name_='Total', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Front is not None or
            self.Back is not None or
            self.Total is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GISParameters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Front is not None:
            showIndent(outfile, level)
            outfile.write('Front=model_.Front(\n')
            self.Front.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Back is not None:
            showIndent(outfile, level)
            outfile.write('Back=model_.Back(\n')
            self.Back.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Total is not None:
            showIndent(outfile, level)
            outfile.write('Total=model_.Total(\n')
            self.Total.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Front':
            obj_ = Front.factory()
            obj_.build(child_)
            self.set_Front(obj_)
        elif nodeName_ == 'Back':
            obj_ = Back.factory()
            obj_.build(child_)
            self.set_Back(obj_)
        elif nodeName_ == 'Total':
            obj_ = Total.factory()
            obj_.build(child_)
            self.set_Total(obj_)
# end class GISParameters


class Front(GeneratedsSuper):
    """The means of transport choosen in the front section are used to
    travel from the starting point to the first station of a
    journey."""
    subclass = None
    superclass = None
    def __init__(self, IndividualTransport=None):
        if IndividualTransport is None:
            self.IndividualTransport = []
        else:
            self.IndividualTransport = IndividualTransport
    def factory(*args_, **kwargs_):
        if Front.subclass:
            return Front.subclass(*args_, **kwargs_)
        else:
            return Front(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndividualTransport(self): return self.IndividualTransport
    def set_IndividualTransport(self, IndividualTransport): self.IndividualTransport = IndividualTransport
    def add_IndividualTransport(self, value): self.IndividualTransport.append(value)
    def insert_IndividualTransport(self, index, value): self.IndividualTransport[index] = value
    def export(self, outfile, level, namespace_='', name_='Front', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Front')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Front'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Front', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IndividualTransport_ in self.IndividualTransport:
            IndividualTransport_.export(outfile, level, namespace_, name_='IndividualTransport', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.IndividualTransport
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Front'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IndividualTransport=[\n')
        level += 1
        for IndividualTransport_ in self.IndividualTransport:
            showIndent(outfile, level)
            outfile.write('model_.IndividualTransport(\n')
            IndividualTransport_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndividualTransport':
            obj_ = IndividualTransport.factory()
            obj_.build(child_)
            self.IndividualTransport.append(obj_)
# end class Front


class Back(GeneratedsSuper):
    """The means of transport choosen in the Back section are considered
    when travelling from the last station to the destination
    address."""
    subclass = None
    superclass = None
    def __init__(self, IndividualTransport=None):
        if IndividualTransport is None:
            self.IndividualTransport = []
        else:
            self.IndividualTransport = IndividualTransport
    def factory(*args_, **kwargs_):
        if Back.subclass:
            return Back.subclass(*args_, **kwargs_)
        else:
            return Back(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndividualTransport(self): return self.IndividualTransport
    def set_IndividualTransport(self, IndividualTransport): self.IndividualTransport = IndividualTransport
    def add_IndividualTransport(self, value): self.IndividualTransport.append(value)
    def insert_IndividualTransport(self, index, value): self.IndividualTransport[index] = value
    def export(self, outfile, level, namespace_='', name_='Back', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Back')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Back'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Back', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IndividualTransport_ in self.IndividualTransport:
            IndividualTransport_.export(outfile, level, namespace_, name_='IndividualTransport', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.IndividualTransport
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Back'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IndividualTransport=[\n')
        level += 1
        for IndividualTransport_ in self.IndividualTransport:
            showIndent(outfile, level)
            outfile.write('model_.IndividualTransport(\n')
            IndividualTransport_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndividualTransport':
            obj_ = IndividualTransport.factory()
            obj_.build(child_)
            self.IndividualTransport.append(obj_)
# end class Back


class IndividualTransport(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, maxDist=None, type_=None, cost=None, minDist=None, maxTime=None, speed=None):
        self.maxDist = _cast(int, maxDist)
        self.type_ = _cast(None, type_)
        self.cost = _cast(int, cost)
        self.minDist = _cast(int, minDist)
        self.maxTime = _cast(int, maxTime)
        self.speed = _cast(int, speed)
        pass
    def factory(*args_, **kwargs_):
        if IndividualTransport.subclass:
            return IndividualTransport.subclass(*args_, **kwargs_)
        else:
            return IndividualTransport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxDist(self): return self.maxDist
    def set_maxDist(self, maxDist): self.maxDist = maxDist
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_cost(self): return self.cost
    def set_cost(self, cost): self.cost = cost
    def get_minDist(self): return self.minDist
    def set_minDist(self, minDist): self.minDist = minDist
    def get_maxTime(self): return self.maxTime
    def set_maxTime(self, maxTime): self.maxTime = maxTime
    def get_speed(self): return self.speed
    def set_speed(self, speed): self.speed = speed
    def export(self, outfile, level, namespace_='', name_='IndividualTransport', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndividualTransport')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IndividualTransport'):
        if self.maxDist is not None and 'maxDist' not in already_processed:
            already_processed.append('maxDist')
            outfile.write(' maxDist="%s"' % self.gds_format_integer(self.maxDist, input_name='maxDist'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.cost is not None and 'cost' not in already_processed:
            already_processed.append('cost')
            outfile.write(' cost="%s"' % self.gds_format_integer(self.cost, input_name='cost'))
        if self.minDist is not None and 'minDist' not in already_processed:
            already_processed.append('minDist')
            outfile.write(' minDist="%s"' % self.gds_format_integer(self.minDist, input_name='minDist'))
        if self.maxTime is not None and 'maxTime' not in already_processed:
            already_processed.append('maxTime')
            outfile.write(' maxTime="%s"' % self.gds_format_integer(self.maxTime, input_name='maxTime'))
        if self.speed is not None and 'speed' not in already_processed:
            already_processed.append('speed')
            outfile.write(' speed="%s"' % self.gds_format_integer(self.speed, input_name='speed'))
    def exportChildren(self, outfile, level, namespace_='', name_='IndividualTransport', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IndividualTransport'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.maxDist is not None and 'maxDist' not in already_processed:
            already_processed.append('maxDist')
            showIndent(outfile, level)
            outfile.write('maxDist = %d,\n' % (self.maxDist,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.cost is not None and 'cost' not in already_processed:
            already_processed.append('cost')
            showIndent(outfile, level)
            outfile.write('cost = %d,\n' % (self.cost,))
        if self.minDist is not None and 'minDist' not in already_processed:
            already_processed.append('minDist')
            showIndent(outfile, level)
            outfile.write('minDist = %d,\n' % (self.minDist,))
        if self.maxTime is not None and 'maxTime' not in already_processed:
            already_processed.append('maxTime')
            showIndent(outfile, level)
            outfile.write('maxTime = %d,\n' % (self.maxTime,))
        if self.speed is not None and 'speed' not in already_processed:
            already_processed.append('speed')
            showIndent(outfile, level)
            outfile.write('speed = %d,\n' % (self.speed,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxDist', node)
        if value is not None and 'maxDist' not in already_processed:
            already_processed.append('maxDist')
            try:
                self.maxDist = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
        value = find_attr_value_('cost', node)
        if value is not None and 'cost' not in already_processed:
            already_processed.append('cost')
            try:
                self.cost = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('minDist', node)
        if value is not None and 'minDist' not in already_processed:
            already_processed.append('minDist')
            try:
                self.minDist = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maxTime', node)
        if value is not None and 'maxTime' not in already_processed:
            already_processed.append('maxTime')
            try:
                self.maxTime = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('speed', node)
        if value is not None and 'speed' not in already_processed:
            already_processed.append('speed')
            try:
                self.speed = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IndividualTransport


class Total(GeneratedsSuper):
    """The means of transport choosen in th total section are used for IV
    connections covering the whole route."""
    subclass = None
    superclass = None
    def __init__(self, IndividualTransport=None):
        if IndividualTransport is None:
            self.IndividualTransport = []
        else:
            self.IndividualTransport = IndividualTransport
    def factory(*args_, **kwargs_):
        if Total.subclass:
            return Total.subclass(*args_, **kwargs_)
        else:
            return Total(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndividualTransport(self): return self.IndividualTransport
    def set_IndividualTransport(self, IndividualTransport): self.IndividualTransport = IndividualTransport
    def add_IndividualTransport(self, value): self.IndividualTransport.append(value)
    def insert_IndividualTransport(self, index, value): self.IndividualTransport[index] = value
    def export(self, outfile, level, namespace_='', name_='Total', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Total')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Total'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Total', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IndividualTransport_ in self.IndividualTransport:
            IndividualTransport_.export(outfile, level, namespace_, name_='IndividualTransport', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.IndividualTransport
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Total'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IndividualTransport=[\n')
        level += 1
        for IndividualTransport_ in self.IndividualTransport:
            showIndent(outfile, level)
            outfile.write('model_.IndividualTransport(\n')
            IndividualTransport_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndividualTransport':
            obj_ = IndividualTransport.factory()
            obj_.build(child_)
            self.IndividualTransport.append(obj_)
# end class Total


class ConScrReq(GeneratedsSuper):
    """ConScrReq specifies a connection scroll request based on a
    previously performed ConReq. It takes a ConResCtxt supplied by
    the ConRes (as the answer to this previously performed ConReq)"""
    subclass = None
    superclass = None
    def __init__(self, nrCons=3, scrDir='F', ConResCtxt=None):
        self.nrCons = _cast(int, nrCons)
        self.scrDir = _cast(None, scrDir)
        self.ConResCtxt = ConResCtxt
    def factory(*args_, **kwargs_):
        if ConScrReq.subclass:
            return ConScrReq.subclass(*args_, **kwargs_)
        else:
            return ConScrReq(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConResCtxt(self): return self.ConResCtxt
    def set_ConResCtxt(self, ConResCtxt): self.ConResCtxt = ConResCtxt
    def get_nrCons(self): return self.nrCons
    def set_nrCons(self, nrCons): self.nrCons = nrCons
    def get_scrDir(self): return self.scrDir
    def set_scrDir(self, scrDir): self.scrDir = scrDir
    def export(self, outfile, level, namespace_='', name_='ConScrReq', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConScrReq')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConScrReq'):
        if self.nrCons is not None and 'nrCons' not in already_processed:
            already_processed.append('nrCons')
            outfile.write(' nrCons="%s"' % self.gds_format_integer(self.nrCons, input_name='nrCons'))
        if self.scrDir is not None and 'scrDir' not in already_processed:
            already_processed.append('scrDir')
            outfile.write(' scrDir=%s' % (self.gds_format_string(quote_attrib(self.scrDir).encode(ExternalEncoding), input_name='scrDir'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConScrReq', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConResCtxt is not None:
            self.ConResCtxt.export(outfile, level, namespace_, name_='ConResCtxt', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ConResCtxt is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConScrReq'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nrCons is not None and 'nrCons' not in already_processed:
            already_processed.append('nrCons')
            showIndent(outfile, level)
            outfile.write('nrCons = %d,\n' % (self.nrCons,))
        if self.scrDir is not None and 'scrDir' not in already_processed:
            already_processed.append('scrDir')
            showIndent(outfile, level)
            outfile.write('scrDir = "%s",\n' % (self.scrDir,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ConResCtxt is not None:
            showIndent(outfile, level)
            outfile.write('ConResCtxt=model_.ConResCtxt(\n')
            self.ConResCtxt.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nrCons', node)
        if value is not None and 'nrCons' not in already_processed:
            already_processed.append('nrCons')
            try:
                self.nrCons = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('scrDir', node)
        if value is not None and 'scrDir' not in already_processed:
            already_processed.append('scrDir')
            self.scrDir = value
            self.scrDir = ' '.join(self.scrDir.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConResCtxt':
            obj_ = ConResCtxt.factory()
            obj_.build(child_)
            self.set_ConResCtxt(obj_)
# end class ConScrReq


class ViaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, min=None, Station=None, Prod=None):
        self.min = _cast(int, min)
        self.Station = Station
        self.Prod = Prod
    def factory(*args_, **kwargs_):
        if ViaType.subclass:
            return ViaType.subclass(*args_, **kwargs_)
        else:
            return ViaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Station(self): return self.Station
    def set_Station(self, Station): self.Station = Station
    def get_Prod(self): return self.Prod
    def set_Prod(self, Prod): self.Prod = Prod
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    def export(self, outfile, level, namespace_='', name_='ViaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ViaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ViaType'):
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            outfile.write(' min="%s"' % self.gds_format_integer(self.min, input_name='min'))
    def exportChildren(self, outfile, level, namespace_='', name_='ViaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Station is not None:
            self.Station.export(outfile, level, namespace_, name_='Station', pretty_print=pretty_print)
        if self.Prod is not None:
            self.Prod.export(outfile, level, namespace_, name_='Prod', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Station is not None or
            self.Prod is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ViaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            showIndent(outfile, level)
            outfile.write('min = %d,\n' % (self.min,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Station is not None:
            showIndent(outfile, level)
            outfile.write('Station=model_.Station(\n')
            self.Station.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Prod is not None:
            showIndent(outfile, level)
            outfile.write('Prod=model_.Prod(\n')
            self.Prod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.append('min')
            try:
                self.min = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Station':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_Station(obj_)
        elif nodeName_ == 'Prod':
            obj_ = Prod.factory()
            obj_.build(child_)
            self.set_Prod(obj_)
# end class ViaType


class RequestLocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, min=None, Address=None, Poi=None, Station=None, Coord=None, extensiontype_=None):
        self.min = _cast(int, min)
        self.Address = Address
        self.Poi = Poi
        self.Station = Station
        self.Coord = Coord
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if RequestLocationType.subclass:
            return RequestLocationType.subclass(*args_, **kwargs_)
        else:
            return RequestLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Poi(self): return self.Poi
    def set_Poi(self, Poi): self.Poi = Poi
    def get_Station(self): return self.Station
    def set_Station(self, Station): self.Station = Station
    def get_Coord(self): return self.Coord
    def set_Coord(self, Coord): self.Coord = Coord
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='RequestLocationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestLocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestLocationType'):
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            outfile.write(' min="%s"' % self.gds_format_integer(self.min, input_name='min'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='RequestLocationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.Poi is not None:
            self.Poi.export(outfile, level, namespace_, name_='Poi', pretty_print=pretty_print)
        if self.Station is not None:
            self.Station.export(outfile, level, namespace_, name_='Station', pretty_print=pretty_print)
        if self.Coord is not None:
            self.Coord.export(outfile, level, namespace_, name_='Coord', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Poi is not None or
            self.Station is not None or
            self.Coord is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RequestLocationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            showIndent(outfile, level)
            outfile.write('min = %d,\n' % (self.min,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=model_.Address(\n')
            self.Address.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Poi is not None:
            showIndent(outfile, level)
            outfile.write('Poi=model_.Poi(\n')
            self.Poi.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Station is not None:
            showIndent(outfile, level)
            outfile.write('Station=model_.Station(\n')
            self.Station.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Coord is not None:
            showIndent(outfile, level)
            outfile.write('Coord=model_.Coord(\n')
            self.Coord.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.append('min')
            try:
                self.min = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_Address(obj_)
        elif nodeName_ == 'Poi':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_Poi(obj_)
        elif nodeName_ == 'Station':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_Station(obj_)
        elif nodeName_ == 'Coord':
            class_obj_ = self.get_class_obj_(child_, LocationType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Coord(obj_)
# end class RequestLocationType


class Prod(GeneratedsSuper):
    """The element Prod contains the product choice and related things. The
    element prod is placed within the Start ans the Via elements.
    The product choice defined in Prod is valid for the section of
    the Journey, that starts at the current location and ends at the
    next Via or Dest element."""
    subclass = None
    superclass = None
    def __init__(self, direct='0', sleeper='0', bike='0', couchette='0', prod=None):
        self.direct = _cast(None, direct)
        self.sleeper = _cast(None, sleeper)
        self.bike = _cast(None, bike)
        self.couchette = _cast(None, couchette)
        self.prod = _cast(None, prod)
        pass
    def factory(*args_, **kwargs_):
        if Prod.subclass:
            return Prod.subclass(*args_, **kwargs_)
        else:
            return Prod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direct(self): return self.direct
    def set_direct(self, direct): self.direct = direct
    def get_sleeper(self): return self.sleeper
    def set_sleeper(self, sleeper): self.sleeper = sleeper
    def get_bike(self): return self.bike
    def set_bike(self, bike): self.bike = bike
    def get_couchette(self): return self.couchette
    def set_couchette(self, couchette): self.couchette = couchette
    def get_prod(self): return self.prod
    def set_prod(self, prod): self.prod = prod
    def export(self, outfile, level, namespace_='', name_='Prod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Prod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Prod'):
        if self.direct is not None and 'direct' not in already_processed:
            already_processed.append('direct')
            outfile.write(' direct=%s' % (self.gds_format_string(quote_attrib(self.direct).encode(ExternalEncoding), input_name='direct'), ))
        if self.sleeper is not None and 'sleeper' not in already_processed:
            already_processed.append('sleeper')
            outfile.write(' sleeper=%s' % (self.gds_format_string(quote_attrib(self.sleeper).encode(ExternalEncoding), input_name='sleeper'), ))
        if self.bike is not None and 'bike' not in already_processed:
            already_processed.append('bike')
            outfile.write(' bike=%s' % (self.gds_format_string(quote_attrib(self.bike).encode(ExternalEncoding), input_name='bike'), ))
        if self.couchette is not None and 'couchette' not in already_processed:
            already_processed.append('couchette')
            outfile.write(' couchette=%s' % (self.gds_format_string(quote_attrib(self.couchette).encode(ExternalEncoding), input_name='couchette'), ))
        if self.prod is not None and 'prod' not in already_processed:
            already_processed.append('prod')
            outfile.write(' prod=%s' % (self.gds_format_string(quote_attrib(self.prod).encode(ExternalEncoding), input_name='prod'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Prod', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Prod'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.direct is not None and 'direct' not in already_processed:
            already_processed.append('direct')
            showIndent(outfile, level)
            outfile.write('direct = "%s",\n' % (self.direct,))
        if self.sleeper is not None and 'sleeper' not in already_processed:
            already_processed.append('sleeper')
            showIndent(outfile, level)
            outfile.write('sleeper = "%s",\n' % (self.sleeper,))
        if self.bike is not None and 'bike' not in already_processed:
            already_processed.append('bike')
            showIndent(outfile, level)
            outfile.write('bike = "%s",\n' % (self.bike,))
        if self.couchette is not None and 'couchette' not in already_processed:
            already_processed.append('couchette')
            showIndent(outfile, level)
            outfile.write('couchette = "%s",\n' % (self.couchette,))
        if self.prod is not None and 'prod' not in already_processed:
            already_processed.append('prod')
            showIndent(outfile, level)
            outfile.write('prod = "%s",\n' % (self.prod,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('direct', node)
        if value is not None and 'direct' not in already_processed:
            already_processed.append('direct')
            self.direct = value
            self.direct = ' '.join(self.direct.split())
        value = find_attr_value_('sleeper', node)
        if value is not None and 'sleeper' not in already_processed:
            already_processed.append('sleeper')
            self.sleeper = value
            self.sleeper = ' '.join(self.sleeper.split())
        value = find_attr_value_('bike', node)
        if value is not None and 'bike' not in already_processed:
            already_processed.append('bike')
            self.bike = value
            self.bike = ' '.join(self.bike.split())
        value = find_attr_value_('couchette', node)
        if value is not None and 'couchette' not in already_processed:
            already_processed.append('couchette')
            self.couchette = value
            self.couchette = ' '.join(self.couchette.split())
        value = find_attr_value_('prod', node)
        if value is not None and 'prod' not in already_processed:
            already_processed.append('prod')
            self.prod = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Prod


class ReqTType(GeneratedsSuper):
    """ReqTType contains the request time for the current request."""
    subclass = None
    superclass = None
    def __init__(self, date=None, a='0', time=None):
        self.date = _cast(None, date)
        self.a = _cast(None, a)
        self.time = _cast(None, time)
        pass
    def factory(*args_, **kwargs_):
        if ReqTType.subclass:
            return ReqTType.subclass(*args_, **kwargs_)
        else:
            return ReqTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_a(self): return self.a
    def set_a(self, a): self.a = a
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def export(self, outfile, level, namespace_='', name_='ReqTType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReqTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReqTType'):
        if self.date is not None and 'date' not in already_processed:
            already_processed.append('date')
            outfile.write(' date=%s' % (self.gds_format_string(quote_attrib(self.date).encode(ExternalEncoding), input_name='date'), ))
        if self.a is not None and 'a' not in already_processed:
            already_processed.append('a')
            outfile.write(' a=%s' % (self.gds_format_string(quote_attrib(self.a).encode(ExternalEncoding), input_name='a'), ))
        if self.time is not None and 'time' not in already_processed:
            already_processed.append('time')
            outfile.write(' time=%s' % (self.gds_format_string(quote_attrib(self.time).encode(ExternalEncoding), input_name='time'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReqTType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReqTType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.date is not None and 'date' not in already_processed:
            already_processed.append('date')
            showIndent(outfile, level)
            outfile.write('date = "%s",\n' % (self.date,))
        if self.a is not None and 'a' not in already_processed:
            already_processed.append('a')
            showIndent(outfile, level)
            outfile.write('a = "%s",\n' % (self.a,))
        if self.time is not None and 'time' not in already_processed:
            already_processed.append('time')
            showIndent(outfile, level)
            outfile.write('time = "%s",\n' % (self.time,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.append('date')
            self.date = value
            self.date = ' '.join(self.date.split())
        value = find_attr_value_('a', node)
        if value is not None and 'a' not in already_processed:
            already_processed.append('a')
            self.a = value
            self.a = ' '.join(self.a.split())
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.append('time')
            self.time = value
            self.time = ' '.join(self.time.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReqTType


class RFlags(GeneratedsSuper):
    """RFlags specifies some essential request flags passed to the Hafas
    kernel.The attribute b specifies the number of connections to
    find in searchdirection backward. This means connections
    starting/ending (depends on the value of the attribute a) before
    the time specified in ReqT. The number must not be below zero
    and must not exceed 6.The attribute f specifies the number of
    connections to find in searchdirection forward. This means
    connections starting/ending (depends on the value of the
    attribute a) after the time specified in ReqT. The number must
    not be below zero and must not exceed 6."""
    subclass = None
    superclass = None
    def __init__(self, b=None, f=None, nrChanges=None, chExtension=0, sMode='N', getPrice='0'):
        self.b = _cast(int, b)
        self.f = _cast(int, f)
        self.nrChanges = _cast(int, nrChanges)
        self.chExtension = _cast(int, chExtension)
        self.sMode = _cast(None, sMode)
        self.getPrice = _cast(None, getPrice)
        pass
    def factory(*args_, **kwargs_):
        if RFlags.subclass:
            return RFlags.subclass(*args_, **kwargs_)
        else:
            return RFlags(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_b(self): return self.b
    def set_b(self, b): self.b = b
    def get_f(self): return self.f
    def set_f(self, f): self.f = f
    def get_nrChanges(self): return self.nrChanges
    def set_nrChanges(self, nrChanges): self.nrChanges = nrChanges
    def get_chExtension(self): return self.chExtension
    def set_chExtension(self, chExtension): self.chExtension = chExtension
    def get_sMode(self): return self.sMode
    def set_sMode(self, sMode): self.sMode = sMode
    def get_getPrice(self): return self.getPrice
    def set_getPrice(self, getPrice): self.getPrice = getPrice
    def export(self, outfile, level, namespace_='', name_='RFlags', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RFlags')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RFlags'):
        if self.b is not None and 'b' not in already_processed:
            already_processed.append('b')
            outfile.write(' b="%s"' % self.gds_format_integer(self.b, input_name='b'))
        if self.f is not None and 'f' not in already_processed:
            already_processed.append('f')
            outfile.write(' f="%s"' % self.gds_format_integer(self.f, input_name='f'))
        if self.nrChanges is not None and 'nrChanges' not in already_processed:
            already_processed.append('nrChanges')
            outfile.write(' nrChanges="%s"' % self.gds_format_integer(self.nrChanges, input_name='nrChanges'))
        if self.chExtension is not None and 'chExtension' not in already_processed:
            already_processed.append('chExtension')
            outfile.write(' chExtension="%s"' % self.gds_format_integer(self.chExtension, input_name='chExtension'))
        if self.sMode is not None and 'sMode' not in already_processed:
            already_processed.append('sMode')
            outfile.write(' sMode=%s' % (self.gds_format_string(quote_attrib(self.sMode).encode(ExternalEncoding), input_name='sMode'), ))
        if self.getPrice is not None and 'getPrice' not in already_processed:
            already_processed.append('getPrice')
            outfile.write(' getPrice=%s' % (self.gds_format_string(quote_attrib(self.getPrice).encode(ExternalEncoding), input_name='getPrice'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RFlags', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RFlags'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.b is not None and 'b' not in already_processed:
            already_processed.append('b')
            showIndent(outfile, level)
            outfile.write('b = %d,\n' % (self.b,))
        if self.f is not None and 'f' not in already_processed:
            already_processed.append('f')
            showIndent(outfile, level)
            outfile.write('f = %d,\n' % (self.f,))
        if self.nrChanges is not None and 'nrChanges' not in already_processed:
            already_processed.append('nrChanges')
            showIndent(outfile, level)
            outfile.write('nrChanges = %d,\n' % (self.nrChanges,))
        if self.chExtension is not None and 'chExtension' not in already_processed:
            already_processed.append('chExtension')
            showIndent(outfile, level)
            outfile.write('chExtension = %d,\n' % (self.chExtension,))
        if self.sMode is not None and 'sMode' not in already_processed:
            already_processed.append('sMode')
            showIndent(outfile, level)
            outfile.write('sMode = "%s",\n' % (self.sMode,))
        if self.getPrice is not None and 'getPrice' not in already_processed:
            already_processed.append('getPrice')
            showIndent(outfile, level)
            outfile.write('getPrice = "%s",\n' % (self.getPrice,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.append('b')
            try:
                self.b = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('f', node)
        if value is not None and 'f' not in already_processed:
            already_processed.append('f')
            try:
                self.f = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nrChanges', node)
        if value is not None and 'nrChanges' not in already_processed:
            already_processed.append('nrChanges')
            try:
                self.nrChanges = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('chExtension', node)
        if value is not None and 'chExtension' not in already_processed:
            already_processed.append('chExtension')
            try:
                self.chExtension = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sMode', node)
        if value is not None and 'sMode' not in already_processed:
            already_processed.append('sMode')
            self.sMode = value
            self.sMode = ' '.join(self.sMode.split())
        value = find_attr_value_('getPrice', node)
        if value is not None and 'getPrice' not in already_processed:
            already_processed.append('getPrice')
            self.getPrice = value
            self.getPrice = ' '.join(self.getPrice.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RFlags


class ResC(GeneratedsSuper):
    """ResC is the container for any type of results, calculated by the
    Hafas server."""
    subclass = None
    superclass = None
    def __init__(self, rt='yes', lang=None, ld=None, ver=None, host=None, prod=None, Err=None, ConRes=None, STBRes=None):
        self.rt = _cast(None, rt)
        self.lang = _cast(None, lang)
        self.ld = _cast(None, ld)
        self.ver = _cast(None, ver)
        self.host = _cast(None, host)
        self.prod = _cast(None, prod)
        if Err is None:
            self.Err = []
        else:
            self.Err = Err
        self.ConRes = ConRes
        self.STBRes = STBRes
    def factory(*args_, **kwargs_):
        if ResC.subclass:
            return ResC.subclass(*args_, **kwargs_)
        else:
            return ResC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Err(self): return self.Err
    def set_Err(self, Err): self.Err = Err
    def add_Err(self, value): self.Err.append(value)
    def insert_Err(self, index, value): self.Err[index] = value
    def get_ConRes(self): return self.ConRes
    def set_ConRes(self, ConRes): self.ConRes = ConRes
    def get_STBRes(self): return self.STBRes
    def set_STBRes(self, STBRes): self.STBRes = STBRes
    def get_rt(self): return self.rt
    def set_rt(self, rt): self.rt = rt
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_ld(self): return self.ld
    def set_ld(self, ld): self.ld = ld
    def get_ver(self): return self.ver
    def set_ver(self, ver): self.ver = ver
    def get_host(self): return self.host
    def set_host(self, host): self.host = host
    def get_prod(self): return self.prod
    def set_prod(self, prod): self.prod = prod
    def export(self, outfile, level, namespace_='', name_='ResC', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResC')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResC'):
        if self.rt is not None and 'rt' not in already_processed:
            already_processed.append('rt')
            outfile.write(' rt=%s' % (self.gds_format_string(quote_attrib(self.rt).encode(ExternalEncoding), input_name='rt'), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.ld is not None and 'ld' not in already_processed:
            already_processed.append('ld')
            outfile.write(' ld=%s' % (self.gds_format_string(quote_attrib(self.ld).encode(ExternalEncoding), input_name='ld'), ))
        if self.ver is not None and 'ver' not in already_processed:
            already_processed.append('ver')
            outfile.write(' ver=%s' % (self.gds_format_string(quote_attrib(self.ver).encode(ExternalEncoding), input_name='ver'), ))
        if self.host is not None and 'host' not in already_processed:
            already_processed.append('host')
            outfile.write(' host=%s' % (self.gds_format_string(quote_attrib(self.host).encode(ExternalEncoding), input_name='host'), ))
        if self.prod is not None and 'prod' not in already_processed:
            already_processed.append('prod')
            outfile.write(' prod=%s' % (self.gds_format_string(quote_attrib(self.prod).encode(ExternalEncoding), input_name='prod'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResC', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Err_ in self.Err:
            Err_.export(outfile, level, namespace_, name_='Err', pretty_print=pretty_print)
        if self.ConRes is not None:
            self.ConRes.export(outfile, level, namespace_, name_='ConRes', pretty_print=pretty_print)
        if self.STBRes is not None:
            self.STBRes.export(outfile, level, namespace_, name_='STBRes', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Err or
            self.ConRes is not None or
            self.STBRes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResC'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rt is not None and 'rt' not in already_processed:
            already_processed.append('rt')
            showIndent(outfile, level)
            outfile.write('rt = "%s",\n' % (self.rt,))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.ld is not None and 'ld' not in already_processed:
            already_processed.append('ld')
            showIndent(outfile, level)
            outfile.write('ld = "%s",\n' % (self.ld,))
        if self.ver is not None and 'ver' not in already_processed:
            already_processed.append('ver')
            showIndent(outfile, level)
            outfile.write('ver = "%s",\n' % (self.ver,))
        if self.host is not None and 'host' not in already_processed:
            already_processed.append('host')
            showIndent(outfile, level)
            outfile.write('host = "%s",\n' % (self.host,))
        if self.prod is not None and 'prod' not in already_processed:
            already_processed.append('prod')
            showIndent(outfile, level)
            outfile.write('prod = "%s",\n' % (self.prod,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Err=[\n')
        level += 1
        for Err_ in self.Err:
            showIndent(outfile, level)
            outfile.write('model_.Err(\n')
            Err_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ConRes is not None:
            showIndent(outfile, level)
            outfile.write('ConRes=model_.ConRes(\n')
            self.ConRes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.STBRes is not None:
            showIndent(outfile, level)
            outfile.write('STBRes=model_.STBRes(\n')
            self.STBRes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rt', node)
        if value is not None and 'rt' not in already_processed:
            already_processed.append('rt')
            self.rt = value
            self.rt = ' '.join(self.rt.split())
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('ld', node)
        if value is not None and 'ld' not in already_processed:
            already_processed.append('ld')
            self.ld = value
        value = find_attr_value_('ver', node)
        if value is not None and 'ver' not in already_processed:
            already_processed.append('ver')
            self.ver = value
        value = find_attr_value_('host', node)
        if value is not None and 'host' not in already_processed:
            already_processed.append('host')
            self.host = value
        value = find_attr_value_('prod', node)
        if value is not None and 'prod' not in already_processed:
            already_processed.append('prod')
            self.prod = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Err':
            obj_ = Err.factory()
            obj_.build(child_)
            self.Err.append(obj_)
        elif nodeName_ == 'ConRes':
            obj_ = ConRes.factory()
            obj_.build(child_)
            self.set_ConRes(obj_)
        elif nodeName_ == 'STBRes':
            obj_ = STBRes.factory()
            obj_.build(child_)
            self.set_STBRes(obj_)
# end class ResC


class ConRes(GeneratedsSuper):
    """A ConRes is the connection result. This Type of result is returned
    as a resonse to a connection request (ConReq) or a connection
    scroll request (ConScrReq)."""
    subclass = None
    superclass = None
    def __init__(self, dir=None, Err=None, ConResCtxt=None, ConnectionList=None, PricingResult=None):
        self.dir = _cast(None, dir)
        if Err is None:
            self.Err = []
        else:
            self.Err = Err
        self.ConResCtxt = ConResCtxt
        if ConnectionList is None:
            self.ConnectionList = []
        else:
            self.ConnectionList = ConnectionList
        self.PricingResult = PricingResult
    def factory(*args_, **kwargs_):
        if ConRes.subclass:
            return ConRes.subclass(*args_, **kwargs_)
        else:
            return ConRes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Err(self): return self.Err
    def set_Err(self, Err): self.Err = Err
    def add_Err(self, value): self.Err.append(value)
    def insert_Err(self, index, value): self.Err[index] = value
    def get_ConResCtxt(self): return self.ConResCtxt
    def set_ConResCtxt(self, ConResCtxt): self.ConResCtxt = ConResCtxt
    def get_ConnectionList(self): return self.ConnectionList
    def set_ConnectionList(self, ConnectionList): self.ConnectionList = ConnectionList
    def add_ConnectionList(self, value): self.ConnectionList.append(value)
    def insert_ConnectionList(self, index, value): self.ConnectionList[index] = value
    def get_PricingResult(self): return self.PricingResult
    def set_PricingResult(self, PricingResult): self.PricingResult = PricingResult
    def get_dir(self): return self.dir
    def set_dir(self, dir): self.dir = dir
    def export(self, outfile, level, namespace_='', name_='ConRes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConRes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConRes'):
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.append('dir')
            outfile.write(' dir=%s' % (self.gds_format_string(quote_attrib(self.dir).encode(ExternalEncoding), input_name='dir'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConRes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Err_ in self.Err:
            Err_.export(outfile, level, namespace_, name_='Err', pretty_print=pretty_print)
        if self.ConResCtxt is not None:
            self.ConResCtxt.export(outfile, level, namespace_, name_='ConResCtxt', pretty_print=pretty_print)
        for ConnectionList_ in self.ConnectionList:
            ConnectionList_.export(outfile, level, namespace_, name_='ConnectionList', pretty_print=pretty_print)
        if self.PricingResult is not None:
            self.PricingResult.export(outfile, level, namespace_, name_='PricingResult', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Err or
            self.ConResCtxt is not None or
            self.ConnectionList or
            self.PricingResult is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConRes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dir is not None and 'dir' not in already_processed:
            already_processed.append('dir')
            showIndent(outfile, level)
            outfile.write('dir = "%s",\n' % (self.dir,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Err=[\n')
        level += 1
        for Err_ in self.Err:
            showIndent(outfile, level)
            outfile.write('model_.Err(\n')
            Err_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ConResCtxt is not None:
            showIndent(outfile, level)
            outfile.write('ConResCtxt=model_.ConResCtxt(\n')
            self.ConResCtxt.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ConnectionList=[\n')
        level += 1
        for ConnectionList_ in self.ConnectionList:
            showIndent(outfile, level)
            outfile.write('model_.ConnectionList(\n')
            ConnectionList_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PricingResult is not None:
            showIndent(outfile, level)
            outfile.write('PricingResult=model_.PricingResult(\n')
            self.PricingResult.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dir', node)
        if value is not None and 'dir' not in already_processed:
            already_processed.append('dir')
            self.dir = value
            self.dir = ' '.join(self.dir.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Err':
            obj_ = Err.factory()
            obj_.build(child_)
            self.Err.append(obj_)
        elif nodeName_ == 'ConResCtxt':
            obj_ = ConResCtxt.factory()
            obj_.build(child_)
            self.set_ConResCtxt(obj_)
        elif nodeName_ == 'ConnectionList':
            obj_ = ConnectionList.factory()
            obj_.build(child_)
            self.ConnectionList.append(obj_)
        elif nodeName_ == 'PricingResult':
            obj_ = PricingResult.factory()
            obj_.build(child_)
            self.set_PricingResult(obj_)
# end class ConRes


class Now(GeneratedsSuper):
    """The element Now stands for current time and current date"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Now.subclass:
            return Now.subclass(*args_, **kwargs_)
        else:
            return Now(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Now', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Now')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Now'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Now', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Now'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Now


class Timetable(GeneratedsSuper):
    """The element Timetable stands for the timetable period beginning from
    now."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Timetable.subclass:
            return Timetable.subclass(*args_, **kwargs_)
        else:
            return Timetable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Timetable', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Timetable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Timetable'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Timetable', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Timetable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Timetable


class STBReq(GeneratedsSuper):
    """StationBoardRequestType of StationBoard: ARR -> Arrivalboard, DEP ->
    DepartureBoardThe attribute maxStops describes the number of
    stopovers in the passlist plus 2 (for departure and arrival
    stops). If maxStops equals to zero, only 2 stops - departure and
    arrival are displayed in the passList. If the attribute is
    absent, all available stops are displayed."""
    subclass = None
    superclass = None
    def __init__(self, boardType=None, maxStops=None, Time=None, Period=None, Today=None, Now=None, Timetable=None, TableStation=None, DirectionFilter=None, TrainFilter=None, ProductFilter=None):
        self.boardType = _cast(None, boardType)
        self.maxStops = _cast(int, maxStops)
        self.Time = Time
        self.Period = Period
        self.Today = Today
        self.Now = Now
        self.Timetable = Timetable
        self.TableStation = TableStation
        self.DirectionFilter = DirectionFilter
        self.TrainFilter = TrainFilter
        self.ProductFilter = ProductFilter
    def factory(*args_, **kwargs_):
        if STBReq.subclass:
            return STBReq.subclass(*args_, **kwargs_)
        else:
            return STBReq(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Period(self): return self.Period
    def set_Period(self, Period): self.Period = Period
    def get_Today(self): return self.Today
    def set_Today(self, Today): self.Today = Today
    def get_Now(self): return self.Now
    def set_Now(self, Now): self.Now = Now
    def get_Timetable(self): return self.Timetable
    def set_Timetable(self, Timetable): self.Timetable = Timetable
    def get_TableStation(self): return self.TableStation
    def set_TableStation(self, TableStation): self.TableStation = TableStation
    def get_DirectionFilter(self): return self.DirectionFilter
    def set_DirectionFilter(self, DirectionFilter): self.DirectionFilter = DirectionFilter
    def get_TrainFilter(self): return self.TrainFilter
    def set_TrainFilter(self, TrainFilter): self.TrainFilter = TrainFilter
    def get_ProductFilter(self): return self.ProductFilter
    def set_ProductFilter(self, ProductFilter): self.ProductFilter = ProductFilter
    def get_boardType(self): return self.boardType
    def set_boardType(self, boardType): self.boardType = boardType
    def get_maxStops(self): return self.maxStops
    def set_maxStops(self, maxStops): self.maxStops = maxStops
    def export(self, outfile, level, namespace_='', name_='STBReq', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STBReq')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STBReq'):
        if self.boardType is not None and 'boardType' not in already_processed:
            already_processed.append('boardType')
            outfile.write(' boardType=%s' % (self.gds_format_string(quote_attrib(self.boardType).encode(ExternalEncoding), input_name='boardType'), ))
        if self.maxStops is not None and 'maxStops' not in already_processed:
            already_processed.append('maxStops')
            outfile.write(' maxStops="%s"' % self.gds_format_integer(self.maxStops, input_name='maxStops'))
    def exportChildren(self, outfile, level, namespace_='', name_='STBReq', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
        if self.Period is not None:
            self.Period.export(outfile, level, namespace_, name_='Period', pretty_print=pretty_print)
        if self.Today is not None:
            self.Today.export(outfile, level, namespace_, name_='Today', pretty_print=pretty_print)
        if self.Now is not None:
            self.Now.export(outfile, level, namespace_, name_='Now', pretty_print=pretty_print)
        if self.Timetable is not None:
            self.Timetable.export(outfile, level, namespace_, name_='Timetable', pretty_print=pretty_print)
        if self.TableStation is not None:
            self.TableStation.export(outfile, level, namespace_, name_='TableStation', pretty_print=pretty_print)
        if self.DirectionFilter is not None:
            self.DirectionFilter.export(outfile, level, namespace_, name_='DirectionFilter', pretty_print=pretty_print)
        if self.TrainFilter is not None:
            self.TrainFilter.export(outfile, level, namespace_, name_='TrainFilter', pretty_print=pretty_print)
        if self.ProductFilter is not None:
            self.ProductFilter.export(outfile, level, namespace_, name_='ProductFilter', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Time is not None or
            self.Period is not None or
            self.Today is not None or
            self.Now is not None or
            self.Timetable is not None or
            self.TableStation is not None or
            self.DirectionFilter is not None or
            self.TrainFilter is not None or
            self.ProductFilter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='STBReq'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.boardType is not None and 'boardType' not in already_processed:
            already_processed.append('boardType')
            showIndent(outfile, level)
            outfile.write('boardType = "%s",\n' % (self.boardType,))
        if self.maxStops is not None and 'maxStops' not in already_processed:
            already_processed.append('maxStops')
            showIndent(outfile, level)
            outfile.write('maxStops = %d,\n' % (self.maxStops,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.Time(\n')
            self.Time.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Period is not None:
            showIndent(outfile, level)
            outfile.write('Period=model_.Period(\n')
            self.Period.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Today is not None:
            showIndent(outfile, level)
            outfile.write('Today=model_.Today(\n')
            self.Today.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Now is not None:
            showIndent(outfile, level)
            outfile.write('Now=model_.Now(\n')
            self.Now.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Timetable is not None:
            showIndent(outfile, level)
            outfile.write('Timetable=model_.Timetable(\n')
            self.Timetable.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TableStation is not None:
            showIndent(outfile, level)
            outfile.write('TableStation=model_.TableStation(\n')
            self.TableStation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DirectionFilter is not None:
            showIndent(outfile, level)
            outfile.write('DirectionFilter=model_.DirectionFilter(\n')
            self.DirectionFilter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TrainFilter is not None:
            showIndent(outfile, level)
            outfile.write('TrainFilter=model_.TrainFilter(\n')
            self.TrainFilter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProductFilter is not None:
            showIndent(outfile, level)
            outfile.write('ProductFilter=model_.ProductFilter(\n')
            self.ProductFilter.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('boardType', node)
        if value is not None and 'boardType' not in already_processed:
            already_processed.append('boardType')
            self.boardType = value
            self.boardType = ' '.join(self.boardType.split())
        value = find_attr_value_('maxStops', node)
        if value is not None and 'maxStops' not in already_processed:
            already_processed.append('maxStops')
            try:
                self.maxStops = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Time':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_Time(obj_)
        elif nodeName_ == 'Period':
            obj_ = Period.factory()
            obj_.build(child_)
            self.set_Period(obj_)
        elif nodeName_ == 'Today':
            obj_ = Today.factory()
            obj_.build(child_)
            self.set_Today(obj_)
        elif nodeName_ == 'Now':
            obj_ = Now.factory()
            obj_.build(child_)
            self.set_Now(obj_)
        elif nodeName_ == 'Timetable':
            obj_ = Timetable.factory()
            obj_.build(child_)
            self.set_Timetable(obj_)
        elif nodeName_ == 'TableStation':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_TableStation(obj_)
        elif nodeName_ == 'DirectionFilter':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_DirectionFilter(obj_)
        elif nodeName_ == 'TrainFilter':
            obj_ = TrainFilter.factory()
            obj_.build(child_)
            self.set_TrainFilter(obj_)
        elif nodeName_ == 'ProductFilter':
            obj_ = ProductFilter.factory()
            obj_.build(child_)
            self.set_ProductFilter(obj_)
# end class STBReq


class Today(GeneratedsSuper):
    """Stationboardrequest for the current day."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Today.subclass:
            return Today.subclass(*args_, **kwargs_)
        else:
            return Today(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Today', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Today')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Today'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Today', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Today'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Today


class Period(GeneratedsSuper):
    """A period is requested. If DateBegin and DateEnd are ommitted, a
    table for the whole timetableperiod is generated. If DateBegin
    is ommitted, the current date is taken as the begin of the
    period. If DateEnd is ommitted, the end of the timetable period
    is taken as the end of the requested period"""
    subclass = None
    superclass = None
    def __init__(self, DateBegin=None, DateEnd=None):
        self.DateBegin = DateBegin
        self.DateEnd = DateEnd
    def factory(*args_, **kwargs_):
        if Period.subclass:
            return Period.subclass(*args_, **kwargs_)
        else:
            return Period(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DateBegin(self): return self.DateBegin
    def set_DateBegin(self, DateBegin): self.DateBegin = DateBegin
    def get_DateEnd(self): return self.DateEnd
    def set_DateEnd(self, DateEnd): self.DateEnd = DateEnd
    def export(self, outfile, level, namespace_='', name_='Period', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Period')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Period'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Period', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DateBegin is not None:
            self.DateBegin.export(outfile, level, namespace_, name_='DateBegin', pretty_print=pretty_print)
        if self.DateEnd is not None:
            self.DateEnd.export(outfile, level, namespace_, name_='DateEnd', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.DateBegin is not None or
            self.DateEnd is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Period'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DateBegin is not None:
            showIndent(outfile, level)
            outfile.write('DateBegin=model_.DateBeginType(\n')
            self.DateBegin.exportLiteral(outfile, level, name_='DateBegin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DateEnd is not None:
            showIndent(outfile, level)
            outfile.write('DateEnd=model_.DateEndType(\n')
            self.DateEnd.exportLiteral(outfile, level, name_='DateEnd')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DateBegin':
            obj_ = DateBeginType.factory()
            obj_.build(child_)
            self.set_DateBegin(obj_)
        elif nodeName_ == 'DateEnd':
            obj_ = DateEndType.factory()
            obj_.build(child_)
            self.set_DateEnd(obj_)
# end class Period


class TrainFilter(GeneratedsSuper):
    """The trainFilter takes a category (IC, RE, ...) or a complete train
    name. The output is restricted to trains, that match the given
    category / name."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if TrainFilter.subclass:
            return TrainFilter.subclass(*args_, **kwargs_)
        else:
            return TrainFilter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='TrainFilter', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrainFilter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TrainFilter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TrainFilter', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TrainFilter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TrainFilter


class ProductFilter(GeneratedsSuper):
    """Filter for product classes. The output is restricted to product
    classes that are enabled here. If no ProductFilter is given,
    trains of all productclasses will be returned. The productfilter
    is a string of 0 and 1, where each numer stands for a product
    class, based on the position of the number in the string. The
    leftmost number represents productclass 0, the next productclass
    1 etc. Example: 111000 enables the productclasses 0,1, 2"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ProductFilter.subclass:
            return ProductFilter.subclass(*args_, **kwargs_)
        else:
            return ProductFilter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ProductFilter', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductFilter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductFilter'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProductFilter', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ProductFilter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProductFilter


class STBRes(GeneratedsSuper):
    """Result of a stationboard request (STBReq)"""
    subclass = None
    superclass = None
    def __init__(self, Err=None, JourneyList=None, IList=None):
        self.Err = Err
        self.JourneyList = JourneyList
        self.IList = IList
    def factory(*args_, **kwargs_):
        if STBRes.subclass:
            return STBRes.subclass(*args_, **kwargs_)
        else:
            return STBRes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Err(self): return self.Err
    def set_Err(self, Err): self.Err = Err
    def get_JourneyList(self): return self.JourneyList
    def set_JourneyList(self, JourneyList): self.JourneyList = JourneyList
    def get_IList(self): return self.IList
    def set_IList(self, IList): self.IList = IList
    def export(self, outfile, level, namespace_='', name_='STBRes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STBRes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STBRes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='STBRes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Err is not None:
            self.Err.export(outfile, level, namespace_, name_='Err', pretty_print=pretty_print)
        if self.JourneyList is not None:
            self.JourneyList.export(outfile, level, namespace_, name_='JourneyList', pretty_print=pretty_print)
        if self.IList is not None:
            self.IList.export(outfile, level, namespace_, name_='IList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Err is not None or
            self.JourneyList is not None or
            self.IList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='STBRes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Err is not None:
            showIndent(outfile, level)
            outfile.write('Err=model_.Err(\n')
            self.Err.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JourneyList is not None:
            showIndent(outfile, level)
            outfile.write('JourneyList=model_.JourneyList(\n')
            self.JourneyList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IList is not None:
            showIndent(outfile, level)
            outfile.write('IList=model_.IList(\n')
            self.IList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Err':
            obj_ = Err.factory()
            obj_.build(child_)
            self.set_Err(obj_)
        elif nodeName_ == 'JourneyList':
            obj_ = JourneyList.factory()
            obj_.build(child_)
            self.set_JourneyList(obj_)
        elif nodeName_ == 'IList':
            obj_ = IList.factory()
            obj_.build(child_)
            self.set_IList(obj_)
# end class STBRes


class JourneyList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, STBJourney=None):
        self.STBJourney = STBJourney
    def factory(*args_, **kwargs_):
        if JourneyList.subclass:
            return JourneyList.subclass(*args_, **kwargs_)
        else:
            return JourneyList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STBJourney(self): return self.STBJourney
    def set_STBJourney(self, STBJourney): self.STBJourney = STBJourney
    def export(self, outfile, level, namespace_='', name_='JourneyList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JourneyList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JourneyList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JourneyList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STBJourney is not None:
            self.STBJourney.export(outfile, level, namespace_, name_='STBJourney', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.STBJourney is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JourneyList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.STBJourney is not None:
            showIndent(outfile, level)
            outfile.write('STBJourney=model_.STBJourney(\n')
            self.STBJourney.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STBJourney':
            obj_ = STBJourney.factory()
            obj_.build(child_)
            self.set_STBJourney(obj_)
# end class JourneyList


class STBJourney(GeneratedsSuper):
    """This unique ID identifies the journey (if realtime is
    available).This unique ID identifies the journey in the plan-
    data-set."""
    subclass = None
    superclass = None
    def __init__(self, journeyId=None, trainId=None, MainStop=None, JourneyAttributeList=None, ServiceDaysList=None, IList=None, JProg=None):
        self.journeyId = _cast(None, journeyId)
        self.trainId = _cast(None, trainId)
        self.MainStop = MainStop
        self.JourneyAttributeList = JourneyAttributeList
        self.ServiceDaysList = ServiceDaysList
        self.IList = IList
        self.JProg = JProg
    def factory(*args_, **kwargs_):
        if STBJourney.subclass:
            return STBJourney.subclass(*args_, **kwargs_)
        else:
            return STBJourney(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MainStop(self): return self.MainStop
    def set_MainStop(self, MainStop): self.MainStop = MainStop
    def get_JourneyAttributeList(self): return self.JourneyAttributeList
    def set_JourneyAttributeList(self, JourneyAttributeList): self.JourneyAttributeList = JourneyAttributeList
    def get_ServiceDaysList(self): return self.ServiceDaysList
    def set_ServiceDaysList(self, ServiceDaysList): self.ServiceDaysList = ServiceDaysList
    def get_IList(self): return self.IList
    def set_IList(self, IList): self.IList = IList
    def get_JProg(self): return self.JProg
    def set_JProg(self, JProg): self.JProg = JProg
    def get_journeyId(self): return self.journeyId
    def set_journeyId(self, journeyId): self.journeyId = journeyId
    def get_trainId(self): return self.trainId
    def set_trainId(self, trainId): self.trainId = trainId
    def export(self, outfile, level, namespace_='', name_='STBJourney', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STBJourney')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STBJourney'):
        if self.journeyId is not None and 'journeyId' not in already_processed:
            already_processed.append('journeyId')
            outfile.write(' journeyId=%s' % (self.gds_format_string(quote_attrib(self.journeyId).encode(ExternalEncoding), input_name='journeyId'), ))
        if self.trainId is not None and 'trainId' not in already_processed:
            already_processed.append('trainId')
            outfile.write(' trainId=%s' % (self.gds_format_string(quote_attrib(self.trainId).encode(ExternalEncoding), input_name='trainId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='STBJourney', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MainStop is not None:
            self.MainStop.export(outfile, level, namespace_, name_='MainStop', pretty_print=pretty_print)
        if self.JourneyAttributeList is not None:
            self.JourneyAttributeList.export(outfile, level, namespace_, name_='JourneyAttributeList', pretty_print=pretty_print)
        if self.ServiceDaysList is not None:
            self.ServiceDaysList.export(outfile, level, namespace_, name_='ServiceDaysList', pretty_print=pretty_print)
        if self.IList is not None:
            self.IList.export(outfile, level, namespace_, name_='IList', pretty_print=pretty_print)
        if self.JProg is not None:
            self.JProg.export(outfile, level, namespace_, name_='JProg', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.MainStop is not None or
            self.JourneyAttributeList is not None or
            self.ServiceDaysList is not None or
            self.IList is not None or
            self.JProg is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='STBJourney'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.journeyId is not None and 'journeyId' not in already_processed:
            already_processed.append('journeyId')
            showIndent(outfile, level)
            outfile.write('journeyId = "%s",\n' % (self.journeyId,))
        if self.trainId is not None and 'trainId' not in already_processed:
            already_processed.append('trainId')
            showIndent(outfile, level)
            outfile.write('trainId = "%s",\n' % (self.trainId,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MainStop is not None:
            showIndent(outfile, level)
            outfile.write('MainStop=model_.MainStop(\n')
            self.MainStop.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JourneyAttributeList is not None:
            showIndent(outfile, level)
            outfile.write('JourneyAttributeList=model_.JourneyAttributeList(\n')
            self.JourneyAttributeList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ServiceDaysList is not None:
            showIndent(outfile, level)
            outfile.write('ServiceDaysList=model_.ServiceDaysListType(\n')
            self.ServiceDaysList.exportLiteral(outfile, level, name_='ServiceDaysList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IList is not None:
            showIndent(outfile, level)
            outfile.write('IList=model_.IList(\n')
            self.IList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JProg is not None:
            showIndent(outfile, level)
            outfile.write('JProg=model_.JProg(\n')
            self.JProg.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('journeyId', node)
        if value is not None and 'journeyId' not in already_processed:
            already_processed.append('journeyId')
            self.journeyId = value
        value = find_attr_value_('trainId', node)
        if value is not None and 'trainId' not in already_processed:
            already_processed.append('trainId')
            self.trainId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MainStop':
            obj_ = MainStop.factory()
            obj_.build(child_)
            self.set_MainStop(obj_)
        elif nodeName_ == 'JourneyAttributeList':
            obj_ = JourneyAttributeList.factory()
            obj_.build(child_)
            self.set_JourneyAttributeList(obj_)
        elif nodeName_ == 'ServiceDaysList':
            obj_ = ServiceDaysListType.factory()
            obj_.build(child_)
            self.set_ServiceDaysList(obj_)
        elif nodeName_ == 'IList':
            obj_ = IList.factory()
            obj_.build(child_)
            self.set_IList(obj_)
        elif nodeName_ == 'JProg':
            obj_ = JProg.factory()
            obj_.build(child_)
            self.set_JProg(obj_)
# end class STBJourney


class MainStop(GeneratedsSuper):
    """Tablestation. The BasicStop contained here, will only contain
    Stations, no other type of locations"""
    subclass = None
    superclass = None
    def __init__(self, BasicStop=None):
        self.BasicStop = BasicStop
    def factory(*args_, **kwargs_):
        if MainStop.subclass:
            return MainStop.subclass(*args_, **kwargs_)
        else:
            return MainStop(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BasicStop(self): return self.BasicStop
    def set_BasicStop(self, BasicStop): self.BasicStop = BasicStop
    def export(self, outfile, level, namespace_='', name_='MainStop', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MainStop')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MainStop'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MainStop', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BasicStop is not None:
            self.BasicStop.export(outfile, level, namespace_, name_='BasicStop', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.BasicStop is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MainStop'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BasicStop is not None:
            showIndent(outfile, level)
            outfile.write('BasicStop=model_.BasicStop(\n')
            self.BasicStop.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BasicStop':
            obj_ = BasicStop.factory()
            obj_.build(child_)
            self.set_BasicStop(obj_)
# end class MainStop


class PricingResult(GeneratedsSuper):
    """If pricing information i available, they are stored in the
    PricingResult"""
    subclass = None
    superclass = None
    def __init__(self, PricingList=None):
        if PricingList is None:
            self.PricingList = []
        else:
            self.PricingList = PricingList
    def factory(*args_, **kwargs_):
        if PricingResult.subclass:
            return PricingResult.subclass(*args_, **kwargs_)
        else:
            return PricingResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PricingList(self): return self.PricingList
    def set_PricingList(self, PricingList): self.PricingList = PricingList
    def add_PricingList(self, value): self.PricingList.append(value)
    def insert_PricingList(self, index, value): self.PricingList[index] = value
    def export(self, outfile, level, namespace_='', name_='PricingResult', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingResult'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PricingResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PricingList_ in self.PricingList:
            PricingList_.export(outfile, level, namespace_, name_='PricingList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.PricingList
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PricingResult'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PricingList=[\n')
        level += 1
        for PricingList_ in self.PricingList:
            showIndent(outfile, level)
            outfile.write('model_.PricingList(\n')
            PricingList_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PricingList':
            obj_ = PricingList.factory()
            obj_.build(child_)
            self.PricingList.append(obj_)
# end class PricingResult


class PricingList(GeneratedsSuper):
    """A PricingResult Can have different PricingLists, each of which has
    an attribute Id. This Id is set to the id of the connection, the
    pricingList belongs to. A PricingList will either contain
    elements of type PricingSet or elements of type Pricing."""
    subclass = None
    superclass = None
    def __init__(self, id=None, ParameterList=None, PricingSet=None, Pricing=None):
        self.id = _cast(None, id)
        self.ParameterList = ParameterList
        if PricingSet is None:
            self.PricingSet = []
        else:
            self.PricingSet = PricingSet
        if Pricing is None:
            self.Pricing = []
        else:
            self.Pricing = Pricing
    def factory(*args_, **kwargs_):
        if PricingList.subclass:
            return PricingList.subclass(*args_, **kwargs_)
        else:
            return PricingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParameterList(self): return self.ParameterList
    def set_ParameterList(self, ParameterList): self.ParameterList = ParameterList
    def get_PricingSet(self): return self.PricingSet
    def set_PricingSet(self, PricingSet): self.PricingSet = PricingSet
    def add_PricingSet(self, value): self.PricingSet.append(value)
    def insert_PricingSet(self, index, value): self.PricingSet[index] = value
    def get_Pricing(self): return self.Pricing
    def set_Pricing(self, Pricing): self.Pricing = Pricing
    def add_Pricing(self, value): self.Pricing.append(value)
    def insert_Pricing(self, index, value): self.Pricing[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='PricingList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingList'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PricingList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterList is not None:
            self.ParameterList.export(outfile, level, namespace_, name_='ParameterList', pretty_print=pretty_print)
        for PricingSet_ in self.PricingSet:
            PricingSet_.export(outfile, level, namespace_, name_='PricingSet', pretty_print=pretty_print)
        for Pricing_ in self.Pricing:
            Pricing_.export(outfile, level, namespace_, name_='Pricing', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ParameterList is not None or
            self.PricingSet or
            self.Pricing
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PricingList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ParameterList is not None:
            showIndent(outfile, level)
            outfile.write('ParameterList=model_.ParameterList(\n')
            self.ParameterList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('PricingSet=[\n')
        level += 1
        for PricingSet_ in self.PricingSet:
            showIndent(outfile, level)
            outfile.write('model_.PricingSet(\n')
            PricingSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Pricing=[\n')
        level += 1
        for Pricing_ in self.Pricing:
            showIndent(outfile, level)
            outfile.write('model_.Pricing(\n')
            Pricing_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParameterList':
            obj_ = ParameterList.factory()
            obj_.build(child_)
            self.set_ParameterList(obj_)
        elif nodeName_ == 'PricingSet':
            obj_ = PricingSet.factory()
            obj_.build(child_)
            self.PricingSet.append(obj_)
        elif nodeName_ == 'Pricing':
            obj_ = Pricing.factory()
            obj_.build(child_)
            self.Pricing.append(obj_)
# end class PricingList


class ParameterList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if ParameterList.subclass:
            return ParameterList.subclass(*args_, **kwargs_)
        else:
            return ParameterList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ParameterList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParameterList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParameterList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ParameterList', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ParameterList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ParameterList


class PricingSet(GeneratedsSuper):
    """A PricingSet is used to group Pricing elements, that all share the
    same generic parameters. Therefore the PricingSet contains a
    ParameterList. The parameters supplied in ths list have to be
    applied to all Pricing elements in the surrent PricingSet."""
    subclass = None
    superclass = None
    def __init__(self, ParameterList=None, Pricing=None):
        self.ParameterList = ParameterList
        if Pricing is None:
            self.Pricing = []
        else:
            self.Pricing = Pricing
    def factory(*args_, **kwargs_):
        if PricingSet.subclass:
            return PricingSet.subclass(*args_, **kwargs_)
        else:
            return PricingSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ParameterList(self): return self.ParameterList
    def set_ParameterList(self, ParameterList): self.ParameterList = ParameterList
    def get_Pricing(self): return self.Pricing
    def set_Pricing(self, Pricing): self.Pricing = Pricing
    def add_Pricing(self, value): self.Pricing.append(value)
    def insert_Pricing(self, index, value): self.Pricing[index] = value
    def export(self, outfile, level, namespace_='', name_='PricingSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PricingSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PricingSet'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PricingSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ParameterList is not None:
            self.ParameterList.export(outfile, level, namespace_, name_='ParameterList', pretty_print=pretty_print)
        for Pricing_ in self.Pricing:
            Pricing_.export(outfile, level, namespace_, name_='Pricing', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ParameterList is not None or
            self.Pricing
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PricingSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ParameterList is not None:
            showIndent(outfile, level)
            outfile.write('ParameterList=model_.ParameterList(\n')
            self.ParameterList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Pricing=[\n')
        level += 1
        for Pricing_ in self.Pricing:
            showIndent(outfile, level)
            outfile.write('model_.Pricing(\n')
            Pricing_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ParameterList':
            obj_ = ParameterList.factory()
            obj_.build(child_)
            self.set_ParameterList(obj_)
        elif nodeName_ == 'Pricing':
            obj_ = Pricing.factory()
            obj_.build(child_)
            self.Pricing.append(obj_)
# end class PricingSet


class Pricing(GeneratedsSuper):
    """A Pricing contains all elements to describe one pricing information.
    The number of different pricing elements for one connection
    depends on the data delivered from the pricing subsystem."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, Ticket=None, ParameterList=None):
        self.type_ = _cast(None, type_)
        if Ticket is None:
            self.Ticket = []
        else:
            self.Ticket = Ticket
        self.ParameterList = ParameterList
    def factory(*args_, **kwargs_):
        if Pricing.subclass:
            return Pricing.subclass(*args_, **kwargs_)
        else:
            return Pricing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ticket(self): return self.Ticket
    def set_Ticket(self, Ticket): self.Ticket = Ticket
    def add_Ticket(self, value): self.Ticket.append(value)
    def insert_Ticket(self, index, value): self.Ticket[index] = value
    def get_ParameterList(self): return self.ParameterList
    def set_ParameterList(self, ParameterList): self.ParameterList = ParameterList
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='Pricing', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Pricing')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Pricing'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Pricing', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Ticket_ in self.Ticket:
            Ticket_.export(outfile, level, namespace_, name_='Ticket', pretty_print=pretty_print)
        if self.ParameterList is not None:
            self.ParameterList.export(outfile, level, namespace_, name_='ParameterList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Ticket or
            self.ParameterList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Pricing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Ticket=[\n')
        level += 1
        for Ticket_ in self.Ticket:
            showIndent(outfile, level)
            outfile.write('model_.Ticket(\n')
            Ticket_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ParameterList is not None:
            showIndent(outfile, level)
            outfile.write('ParameterList=model_.ParameterList(\n')
            self.ParameterList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ticket':
            obj_ = Ticket.factory()
            obj_.build(child_)
            self.Ticket.append(obj_)
        elif nodeName_ == 'ParameterList':
            obj_ = ParameterList.factory()
            obj_.build(child_)
            self.set_ParameterList(obj_)
# end class Pricing


class Ticket(GeneratedsSuper):
    """A Ticket contains the name of the Ticket, the price, the number of
    travellers and a generic ParameterList"""
    subclass = None
    superclass = None
    def __init__(self, Tariff=None, Traveller=None, FromText=None, ToText=None, Price=None, ParameterList=None):
        self.Tariff = Tariff
        self.Traveller = Traveller
        self.FromText = FromText
        self.ToText = ToText
        if Price is None:
            self.Price = []
        else:
            self.Price = Price
        self.ParameterList = ParameterList
    def factory(*args_, **kwargs_):
        if Ticket.subclass:
            return Ticket.subclass(*args_, **kwargs_)
        else:
            return Ticket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tariff(self): return self.Tariff
    def set_Tariff(self, Tariff): self.Tariff = Tariff
    def get_Traveller(self): return self.Traveller
    def set_Traveller(self, Traveller): self.Traveller = Traveller
    def get_FromText(self): return self.FromText
    def set_FromText(self, FromText): self.FromText = FromText
    def get_ToText(self): return self.ToText
    def set_ToText(self, ToText): self.ToText = ToText
    def get_Price(self): return self.Price
    def set_Price(self, Price): self.Price = Price
    def add_Price(self, value): self.Price.append(value)
    def insert_Price(self, index, value): self.Price[index] = value
    def get_ParameterList(self): return self.ParameterList
    def set_ParameterList(self, ParameterList): self.ParameterList = ParameterList
    def export(self, outfile, level, namespace_='', name_='Ticket', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Ticket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Ticket'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Ticket', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tariff is not None:
            self.Tariff.export(outfile, level, namespace_, name_='Tariff', pretty_print=pretty_print)
        if self.Traveller is not None:
            self.Traveller.export(outfile, level, namespace_, name_='Traveller', pretty_print=pretty_print)
        if self.FromText is not None:
            self.FromText.export(outfile, level, namespace_, name_='FromText', pretty_print=pretty_print)
        if self.ToText is not None:
            self.ToText.export(outfile, level, namespace_, name_='ToText', pretty_print=pretty_print)
        for Price_ in self.Price:
            Price_.export(outfile, level, namespace_, name_='Price', pretty_print=pretty_print)
        if self.ParameterList is not None:
            self.ParameterList.export(outfile, level, namespace_, name_='ParameterList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Tariff is not None or
            self.Traveller is not None or
            self.FromText is not None or
            self.ToText is not None or
            self.Price or
            self.ParameterList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Ticket'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Tariff is not None:
            showIndent(outfile, level)
            outfile.write('Tariff=model_.Tariff(\n')
            self.Tariff.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Traveller is not None:
            showIndent(outfile, level)
            outfile.write('Traveller=model_.Traveller(\n')
            self.Traveller.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FromText is not None:
            showIndent(outfile, level)
            outfile.write('FromText=model_.FromText(\n')
            self.FromText.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ToText is not None:
            showIndent(outfile, level)
            outfile.write('ToText=model_.ToText(\n')
            self.ToText.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Price=[\n')
        level += 1
        for Price_ in self.Price:
            showIndent(outfile, level)
            outfile.write('model_.Price(\n')
            Price_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ParameterList is not None:
            showIndent(outfile, level)
            outfile.write('ParameterList=model_.ParameterList(\n')
            self.ParameterList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tariff':
            obj_ = Tariff.factory()
            obj_.build(child_)
            self.set_Tariff(obj_)
        elif nodeName_ == 'Traveller':
            obj_ = Traveller.factory()
            obj_.build(child_)
            self.set_Traveller(obj_)
        elif nodeName_ == 'FromText':
            obj_ = FromText.factory()
            obj_.build(child_)
            self.set_FromText(obj_)
        elif nodeName_ == 'ToText':
            obj_ = ToText.factory()
            obj_.build(child_)
            self.set_ToText(obj_)
        elif nodeName_ == 'Price':
            obj_ = Price.factory()
            obj_.build(child_)
            self.Price.append(obj_)
        elif nodeName_ == 'ParameterList':
            obj_ = ParameterList.factory()
            obj_.build(child_)
            self.set_ParameterList(obj_)
# end class Ticket


class Tariff(GeneratedsSuper):
    """A Tariff contains the textual description of the tariff and a code
    for this tariff."""
    subclass = None
    superclass = None
    def __init__(self, code=None, Text=None):
        self.code = _cast(None, code)
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if Tariff.subclass:
            return Tariff.subclass(*args_, **kwargs_)
        else:
            return Tariff(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def export(self, outfile, level, namespace_='', name_='Tariff', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Tariff')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Tariff'):
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Tariff', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Tariff'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            showIndent(outfile, level)
            outfile.write('code = "%s",\n' % (self.code,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.append('code')
            self.code = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class Tariff


class Traveller(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TravellerCategory=None, Text=None):
        if TravellerCategory is None:
            self.TravellerCategory = []
        else:
            self.TravellerCategory = TravellerCategory
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if Traveller.subclass:
            return Traveller.subclass(*args_, **kwargs_)
        else:
            return Traveller(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TravellerCategory(self): return self.TravellerCategory
    def set_TravellerCategory(self, TravellerCategory): self.TravellerCategory = TravellerCategory
    def add_TravellerCategory(self, value): self.TravellerCategory.append(value)
    def insert_TravellerCategory(self, index, value): self.TravellerCategory[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def export(self, outfile, level, namespace_='', name_='Traveller', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Traveller')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Traveller'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Traveller', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TravellerCategory_ in self.TravellerCategory:
            TravellerCategory_.export(outfile, level, namespace_, name_='TravellerCategory', pretty_print=pretty_print)
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.TravellerCategory or
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Traveller'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('TravellerCategory=[\n')
        level += 1
        for TravellerCategory_ in self.TravellerCategory:
            showIndent(outfile, level)
            outfile.write('model_.TravellerCategory(\n')
            TravellerCategory_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TravellerCategory':
            obj_ = TravellerCategory.factory()
            obj_.build(child_)
            self.TravellerCategory.append(obj_)
        elif nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class Traveller


class TravellerCategory(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, category=None, amount=None):
        self.category = _cast(None, category)
        self.amount = _cast(None, amount)
        pass
    def factory(*args_, **kwargs_):
        if TravellerCategory.subclass:
            return TravellerCategory.subclass(*args_, **kwargs_)
        else:
            return TravellerCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def export(self, outfile, level, namespace_='', name_='TravellerCategory', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TravellerCategory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TravellerCategory'):
        if self.category is not None and 'category' not in already_processed:
            already_processed.append('category')
            outfile.write(' category=%s' % (self.gds_format_string(quote_attrib(self.category).encode(ExternalEncoding), input_name='category'), ))
        if self.amount is not None and 'amount' not in already_processed:
            already_processed.append('amount')
            outfile.write(' amount=%s' % (self.gds_format_string(quote_attrib(self.amount).encode(ExternalEncoding), input_name='amount'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TravellerCategory', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TravellerCategory'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.category is not None and 'category' not in already_processed:
            already_processed.append('category')
            showIndent(outfile, level)
            outfile.write('category = "%s",\n' % (self.category,))
        if self.amount is not None and 'amount' not in already_processed:
            already_processed.append('amount')
            showIndent(outfile, level)
            outfile.write('amount = "%s",\n' % (self.amount,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.append('category')
            self.category = value
        value = find_attr_value_('amount', node)
        if value is not None and 'amount' not in already_processed:
            already_processed.append('amount')
            self.amount = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TravellerCategory


class FromText(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Text=None):
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if FromText.subclass:
            return FromText.subclass(*args_, **kwargs_)
        else:
            return FromText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def export(self, outfile, level, namespace_='', name_='FromText', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FromText')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FromText'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FromText', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FromText'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class FromText


class ToText(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Text=None):
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if ToText.subclass:
            return ToText.subclass(*args_, **kwargs_)
        else:
            return ToText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def export(self, outfile, level, namespace_='', name_='ToText', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToText')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ToText'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ToText', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ToText'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class ToText


class Price(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, currency=None, price=None):
        self.currency = _cast(None, currency)
        self.price = _cast(int, price)
        pass
    def factory(*args_, **kwargs_):
        if Price.subclass:
            return Price.subclass(*args_, **kwargs_)
        else:
            return Price(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_price(self): return self.price
    def set_price(self, price): self.price = price
    def export(self, outfile, level, namespace_='', name_='Price', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Price')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Price'):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            outfile.write(' currency=%s' % (self.gds_format_string(quote_attrib(self.currency).encode(ExternalEncoding), input_name='currency'), ))
        if self.price is not None and 'price' not in already_processed:
            already_processed.append('price')
            outfile.write(' price="%s"' % self.gds_format_integer(self.price, input_name='price'))
    def exportChildren(self, outfile, level, namespace_='', name_='Price', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Price'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.currency is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            showIndent(outfile, level)
            outfile.write('currency = "%s",\n' % (self.currency,))
        if self.price is not None and 'price' not in already_processed:
            already_processed.append('price')
            showIndent(outfile, level)
            outfile.write('price = %d,\n' % (self.price,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('currency', node)
        if value is not None and 'currency' not in already_processed:
            already_processed.append('currency')
            self.currency = value
        value = find_attr_value_('price', node)
        if value is not None and 'price' not in already_processed:
            already_processed.append('price')
            try:
                self.price = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Price


class ConnectionList(GeneratedsSuper):
    """The ConnectionList element is the container for all connections
    calculated by the Hafas server."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, Err=None, Connection=None):
        self.type_ = _cast(None, type_)
        self.Err = Err
        if Connection is None:
            self.Connection = []
        else:
            self.Connection = Connection
    def factory(*args_, **kwargs_):
        if ConnectionList.subclass:
            return ConnectionList.subclass(*args_, **kwargs_)
        else:
            return ConnectionList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Err(self): return self.Err
    def set_Err(self, Err): self.Err = Err
    def get_Connection(self): return self.Connection
    def set_Connection(self, Connection): self.Connection = Connection
    def add_Connection(self, value): self.Connection.append(value)
    def insert_Connection(self, index, value): self.Connection[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='ConnectionList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConnectionList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConnectionList'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConnectionList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Err is not None:
            self.Err.export(outfile, level, namespace_, name_='Err', pretty_print=pretty_print)
        for Connection_ in self.Connection:
            Connection_.export(outfile, level, namespace_, name_='Connection', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Err is not None or
            self.Connection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConnectionList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Err is not None:
            showIndent(outfile, level)
            outfile.write('Err=model_.Err(\n')
            self.Err.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Connection=[\n')
        level += 1
        for Connection_ in self.Connection:
            showIndent(outfile, level)
            outfile.write('model_.Connection(\n')
            Connection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Err':
            obj_ = Err.factory()
            obj_.build(child_)
            self.set_Err(obj_)
        elif nodeName_ == 'Connection':
            obj_ = Connection.factory()
            obj_.build(child_)
            self.Connection.append(obj_)
# end class ConnectionList


class ConResCtxt(GeneratedsSuper):
    """The element ConResCtxt is part of a ConRes. For a subsequent
    ConScrReq, the ConResCtxt must be supplied as a part of the
    request.."""
    subclass = None
    superclass = None
    def __init__(self, b='1', f='1', valueOf_=None, mixedclass_=None, content_=None):
        self.b = _cast(None, b)
        self.f = _cast(None, f)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ConResCtxt.subclass:
            return ConResCtxt.subclass(*args_, **kwargs_)
        else:
            return ConResCtxt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_b(self): return self.b
    def set_b(self, b): self.b = b
    def get_f(self): return self.f
    def set_f(self, f): self.f = f
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='ConResCtxt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConResCtxt')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConResCtxt'):
        if self.b is not None and 'b' not in already_processed:
            already_processed.append('b')
            outfile.write(' b=%s' % (self.gds_format_string(quote_attrib(self.b).encode(ExternalEncoding), input_name='b'), ))
        if self.f is not None and 'f' not in already_processed:
            already_processed.append('f')
            outfile.write(' f=%s' % (self.gds_format_string(quote_attrib(self.f).encode(ExternalEncoding), input_name='f'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConResCtxt', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConResCtxt'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.b is not None and 'b' not in already_processed:
            already_processed.append('b')
            showIndent(outfile, level)
            outfile.write('b = "%s",\n' % (self.b,))
        if self.f is not None and 'f' not in already_processed:
            already_processed.append('f')
            showIndent(outfile, level)
            outfile.write('f = "%s",\n' % (self.f,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('b', node)
        if value is not None and 'b' not in already_processed:
            already_processed.append('b')
            self.b = value
            self.b = ' '.join(self.b.split())
        value = find_attr_value_('f', node)
        if value is not None and 'f' not in already_processed:
            already_processed.append('f')
            self.f = value
            self.f = ' '.join(self.f.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ConResCtxt


class TimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Time=None, extensiontype_=None):
        self.Time = Time
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if TimeType.subclass:
            return TimeType.subclass(*args_, **kwargs_)
        else:
            return TimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='TimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Time is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.Time(\n')
            self.Time.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Time':
            obj_ = Time.factory()
            obj_.build(child_)
            self.set_Time(obj_)
# end class TimeType


class Time(GeneratedsSuper):
    """The format of the Time element is [xxd]hh:mm:ss. xx represents a day
    offset. All offsets are relative to the base date of the
    connection. For example a time 01d12:30:00 means 12:30 at the
    first day following the day specified as the base date in the
    Date element in the Overview section of the connection."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Time.subclass:
            return Time.subclass(*args_, **kwargs_)
        else:
            return Time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Time', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Time')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Time'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Time', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Time'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class Time


class LocationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, y=None, x=None, z=None, type_='WGS84', name=None, extensiontype_=None):
        self.y = _cast(int, y)
        self.x = _cast(int, x)
        self.z = _cast(int, z)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if LocationType.subclass:
            return LocationType.subclass(*args_, **kwargs_)
        else:
            return LocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_z(self): return self.z
    def set_z(self, z): self.z = z
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='', name_='LocationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocationType'):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            outfile.write(' y="%s"' % self.gds_format_integer(self.y, input_name='y'))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            outfile.write(' x="%s"' % self.gds_format_integer(self.x, input_name='x'))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            outfile.write(' z="%s"' % self.gds_format_integer(self.z, input_name='z'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='LocationType', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LocationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.y is not None and 'y' not in already_processed:
            already_processed.append('y')
            showIndent(outfile, level)
            outfile.write('y = %d,\n' % (self.y,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.append('x')
            showIndent(outfile, level)
            outfile.write('x = %d,\n' % (self.x,))
        if self.z is not None and 'z' not in already_processed:
            already_processed.append('z')
            showIndent(outfile, level)
            outfile.write('z = %d,\n' % (self.z,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.append('y')
            try:
                self.y = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.append('x')
            try:
                self.x = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('z', node)
        if value is not None and 'z' not in already_processed:
            already_processed.append('z')
            try:
                self.z = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocationType


class StationType(LocationType):
    subclass = None
    superclass = LocationType
    def __init__(self, y=None, x=None, z=None, type_='WGS84', name=None, externalStationNr=None, externalId=None):
        super(StationType, self).__init__(y, x, z, type_, name, )
        self.externalStationNr = _cast(int, externalStationNr)
        self.externalId = _cast(None, externalId)
        pass
    def factory(*args_, **kwargs_):
        if StationType.subclass:
            return StationType.subclass(*args_, **kwargs_)
        else:
            return StationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_externalStationNr(self): return self.externalStationNr
    def set_externalStationNr(self, externalStationNr): self.externalStationNr = externalStationNr
    def get_externalId(self): return self.externalId
    def set_externalId(self, externalId): self.externalId = externalId
    def export(self, outfile, level, namespace_='', name_='StationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StationType'):
        super(StationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StationType')
        if self.externalStationNr is not None and 'externalStationNr' not in already_processed:
            already_processed.append('externalStationNr')
            outfile.write(' externalStationNr="%s"' % self.gds_format_integer(self.externalStationNr, input_name='externalStationNr'))
        if self.externalId is not None and 'externalId' not in already_processed:
            already_processed.append('externalId')
            outfile.write(' externalId=%s' % (self.gds_format_string(quote_attrib(self.externalId).encode(ExternalEncoding), input_name='externalId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='StationType', fromsubclass_=False, pretty_print=True):
        super(StationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def hasContent_(self):
        if (
            super(StationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.externalStationNr is not None and 'externalStationNr' not in already_processed:
            already_processed.append('externalStationNr')
            showIndent(outfile, level)
            outfile.write('externalStationNr = %d,\n' % (self.externalStationNr,))
        if self.externalId is not None and 'externalId' not in already_processed:
            already_processed.append('externalId')
            showIndent(outfile, level)
            outfile.write('externalId = "%s",\n' % (self.externalId,))
        super(StationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StationType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('externalStationNr', node)
        if value is not None and 'externalStationNr' not in already_processed:
            already_processed.append('externalStationNr')
            try:
                self.externalStationNr = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('externalId', node)
        if value is not None and 'externalId' not in already_processed:
            already_processed.append('externalId')
            self.externalId = value
        super(StationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(StationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StationType


class Text(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Text.subclass:
            return Text.subclass(*args_, **kwargs_)
        else:
            return Text(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='Text', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Text')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
        outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Text'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Text', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Text'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
            self.lang = ' '.join(self.lang.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class Text


class NamedValue(GeneratedsSuper):
    """A named value is used to specify generic extensions. The attribute
    name specifies the name of the element, the attribute valuetakes
    the corresponding value."""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if NamedValue.subclass:
            return NamedValue.subclass(*args_, **kwargs_)
        else:
            return NamedValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='NamedValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NamedValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NamedValue'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NamedValue', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NamedValue'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NamedValue


class ServiceDays(GeneratedsSuper):
    """The element ServiceDays specifies the days, the current connection
    is served. There are two representations of the servicedays. The
    ServiceBits take a bitfield of the servicedays. In addition
    there is a textual description of the servicedays, separated
    into regular servicedays (Mo-Fr) and irregular servicedays (not
    24., 25, 26. Dez...) The textual description is given in a macro
    language, where all language specific parts are substituted with
    macros of the form $(vt<xy>)"""
    subclass = None
    superclass = None
    def __init__(self, ServiceBits=None, RegularServiceText=None, IrregularServiceText=None):
        self.ServiceBits = ServiceBits
        self.RegularServiceText = RegularServiceText
        self.IrregularServiceText = IrregularServiceText
    def factory(*args_, **kwargs_):
        if ServiceDays.subclass:
            return ServiceDays.subclass(*args_, **kwargs_)
        else:
            return ServiceDays(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceBits(self): return self.ServiceBits
    def set_ServiceBits(self, ServiceBits): self.ServiceBits = ServiceBits
    def get_RegularServiceText(self): return self.RegularServiceText
    def set_RegularServiceText(self, RegularServiceText): self.RegularServiceText = RegularServiceText
    def get_IrregularServiceText(self): return self.IrregularServiceText
    def set_IrregularServiceText(self, IrregularServiceText): self.IrregularServiceText = IrregularServiceText
    def export(self, outfile, level, namespace_='', name_='ServiceDays', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceDays')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceDays'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceDays', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceBits is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sServiceBits>%s</%sServiceBits>%s' % (namespace_, self.gds_format_string(quote_xml(self.ServiceBits).encode(ExternalEncoding), input_name='ServiceBits'), namespace_, eol_))
        if self.RegularServiceText is not None:
            self.RegularServiceText.export(outfile, level, namespace_, name_='RegularServiceText', pretty_print=pretty_print)
        if self.IrregularServiceText is not None:
            self.IrregularServiceText.export(outfile, level, namespace_, name_='IrregularServiceText', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ServiceBits is not None or
            self.RegularServiceText is not None or
            self.IrregularServiceText is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceDays'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ServiceBits is not None:
            showIndent(outfile, level)
            outfile.write('ServiceBits=%s,\n' % quote_python(self.ServiceBits).encode(ExternalEncoding))
        if self.RegularServiceText is not None:
            showIndent(outfile, level)
            outfile.write('RegularServiceText=model_.RegularServiceText(\n')
            self.RegularServiceText.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IrregularServiceText is not None:
            showIndent(outfile, level)
            outfile.write('IrregularServiceText=model_.IrregularServiceText(\n')
            self.IrregularServiceText.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceBits':
            ServiceBits_ = child_.text
            ServiceBits_ = self.gds_validate_string(ServiceBits_, node, 'ServiceBits')
            self.ServiceBits = ServiceBits_
        elif nodeName_ == 'RegularServiceText':
            obj_ = RegularServiceText.factory()
            obj_.build(child_)
            self.set_RegularServiceText(obj_)
        elif nodeName_ == 'IrregularServiceText':
            obj_ = IrregularServiceText.factory()
            obj_.build(child_)
            self.set_IrregularServiceText(obj_)
# end class ServiceDays


class RegularServiceText(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Text=None):
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if RegularServiceText.subclass:
            return RegularServiceText.subclass(*args_, **kwargs_)
        else:
            return RegularServiceText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def export(self, outfile, level, namespace_='', name_='RegularServiceText', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegularServiceText')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegularServiceText'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RegularServiceText', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegularServiceText'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class RegularServiceText


class IrregularServiceText(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Text=None):
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if IrregularServiceText.subclass:
            return IrregularServiceText.subclass(*args_, **kwargs_)
        else:
            return IrregularServiceText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def export(self, outfile, level, namespace_='', name_='IrregularServiceText', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IrregularServiceText')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IrregularServiceText'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IrregularServiceText', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IrregularServiceText'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class IrregularServiceText


class Connection(GeneratedsSuper):
    """The element Connection is a container for all the data belonging to
    one connection."""
    subclass = None
    superclass = None
    def __init__(self, id=None, RtStateList=None, Overview=None, ConSectionList=None, IList=None, CommentList=None, AltConList=None):
        self.id = _cast(None, id)
        self.RtStateList = RtStateList
        self.Overview = Overview
        self.ConSectionList = ConSectionList
        self.IList = IList
        self.CommentList = CommentList
        self.AltConList = AltConList
    def factory(*args_, **kwargs_):
        if Connection.subclass:
            return Connection.subclass(*args_, **kwargs_)
        else:
            return Connection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RtStateList(self): return self.RtStateList
    def set_RtStateList(self, RtStateList): self.RtStateList = RtStateList
    def get_Overview(self): return self.Overview
    def set_Overview(self, Overview): self.Overview = Overview
    def get_ConSectionList(self): return self.ConSectionList
    def set_ConSectionList(self, ConSectionList): self.ConSectionList = ConSectionList
    def get_IList(self): return self.IList
    def set_IList(self, IList): self.IList = IList
    def get_CommentList(self): return self.CommentList
    def set_CommentList(self, CommentList): self.CommentList = CommentList
    def get_AltConList(self): return self.AltConList
    def set_AltConList(self, AltConList): self.AltConList = AltConList
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='Connection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Connection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Connection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Connection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RtStateList is not None:
            self.RtStateList.export(outfile, level, namespace_, name_='RtStateList', pretty_print=pretty_print)
        if self.Overview is not None:
            self.Overview.export(outfile, level, namespace_, name_='Overview', pretty_print=pretty_print)
        if self.ConSectionList is not None:
            self.ConSectionList.export(outfile, level, namespace_, name_='ConSectionList', pretty_print=pretty_print)
        if self.IList is not None:
            self.IList.export(outfile, level, namespace_, name_='IList', pretty_print=pretty_print)
        if self.CommentList is not None:
            self.CommentList.export(outfile, level, namespace_, name_='CommentList', pretty_print=pretty_print)
        if self.AltConList is not None:
            self.AltConList.export(outfile, level, namespace_, name_='AltConList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.RtStateList is not None or
            self.Overview is not None or
            self.ConSectionList is not None or
            self.IList is not None or
            self.CommentList is not None or
            self.AltConList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Connection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RtStateList is not None:
            showIndent(outfile, level)
            outfile.write('RtStateList=model_.RtStateList(\n')
            self.RtStateList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Overview is not None:
            showIndent(outfile, level)
            outfile.write('Overview=model_.Overview(\n')
            self.Overview.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConSectionList is not None:
            showIndent(outfile, level)
            outfile.write('ConSectionList=model_.ConSectionList(\n')
            self.ConSectionList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IList is not None:
            showIndent(outfile, level)
            outfile.write('IList=model_.IList(\n')
            self.IList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CommentList is not None:
            showIndent(outfile, level)
            outfile.write('CommentList=model_.CommentList(\n')
            self.CommentList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AltConList is not None:
            showIndent(outfile, level)
            outfile.write('AltConList=model_.AltConList(\n')
            self.AltConList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RtStateList':
            obj_ = RtStateList.factory()
            obj_.build(child_)
            self.set_RtStateList(obj_)
        elif nodeName_ == 'Overview':
            obj_ = Overview.factory()
            obj_.build(child_)
            self.set_Overview(obj_)
        elif nodeName_ == 'ConSectionList':
            obj_ = ConSectionList.factory()
            obj_.build(child_)
            self.set_ConSectionList(obj_)
        elif nodeName_ == 'IList':
            obj_ = IList.factory()
            obj_.build(child_)
            self.set_IList(obj_)
        elif nodeName_ == 'CommentList':
            obj_ = CommentList.factory()
            obj_.build(child_)
            self.set_CommentList(obj_)
        elif nodeName_ == 'AltConList':
            obj_ = AltConList.factory()
            obj_.build(child_)
            self.set_AltConList(obj_)
# end class Connection


class Overview(GeneratedsSuper):
    """The element overview takes all relevant elements to display an
    overview of the connection. This includes Date (the base date),
    Departure, Arrival, Transfers, Duration, ServiceDays and
    ContextURL."""
    subclass = None
    superclass = None
    def __init__(self, Date=None, Departure=None, Arrival=None, Transfers=None, Duration=None, ServiceDays=None, Products=None, ContextURL=None):
        self.Date = Date
        self.Departure = Departure
        self.Arrival = Arrival
        self.Transfers = Transfers
        self.Duration = Duration
        self.ServiceDays = ServiceDays
        self.Products = Products
        self.ContextURL = ContextURL
    def factory(*args_, **kwargs_):
        if Overview.subclass:
            return Overview.subclass(*args_, **kwargs_)
        else:
            return Overview(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Departure(self): return self.Departure
    def set_Departure(self, Departure): self.Departure = Departure
    def get_Arrival(self): return self.Arrival
    def set_Arrival(self, Arrival): self.Arrival = Arrival
    def get_Transfers(self): return self.Transfers
    def set_Transfers(self, Transfers): self.Transfers = Transfers
    def get_Duration(self): return self.Duration
    def set_Duration(self, Duration): self.Duration = Duration
    def get_ServiceDays(self): return self.ServiceDays
    def set_ServiceDays(self, ServiceDays): self.ServiceDays = ServiceDays
    def get_Products(self): return self.Products
    def set_Products(self, Products): self.Products = Products
    def get_ContextURL(self): return self.ContextURL
    def set_ContextURL(self, ContextURL): self.ContextURL = ContextURL
    def export(self, outfile, level, namespace_='', name_='Overview', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Overview')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Overview'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Overview', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.Date).encode(ExternalEncoding), input_name='Date'), namespace_, eol_))
        if self.Departure is not None:
            self.Departure.export(outfile, level, namespace_, name_='Departure', pretty_print=pretty_print)
        if self.Arrival is not None:
            self.Arrival.export(outfile, level, namespace_, name_='Arrival', pretty_print=pretty_print)
        if self.Transfers is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTransfers>%s</%sTransfers>%s' % (namespace_, self.gds_format_string(quote_xml(self.Transfers).encode(ExternalEncoding), input_name='Transfers'), namespace_, eol_))
        if self.Duration is not None:
            self.Duration.export(outfile, level, namespace_, name_='Duration', pretty_print=pretty_print)
        if self.ServiceDays is not None:
            self.ServiceDays.export(outfile, level, namespace_, name_='ServiceDays', pretty_print=pretty_print)
        if self.Products is not None:
            self.Products.export(outfile, level, namespace_, name_='Products', pretty_print=pretty_print)
        if self.ContextURL is not None:
            self.ContextURL.export(outfile, level, namespace_, name_='ContextURL', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Date is not None or
            self.Departure is not None or
            self.Arrival is not None or
            self.Transfers is not None or
            self.Duration is not None or
            self.ServiceDays is not None or
            self.Products is not None or
            self.ContextURL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Overview'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=%s,\n' % quote_python(self.Date).encode(ExternalEncoding))
        if self.Departure is not None:
            showIndent(outfile, level)
            outfile.write('Departure=model_.Departure(\n')
            self.Departure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Arrival is not None:
            showIndent(outfile, level)
            outfile.write('Arrival=model_.Arrival(\n')
            self.Arrival.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Transfers is not None:
            showIndent(outfile, level)
            outfile.write('Transfers=%s,\n' % quote_python(self.Transfers).encode(ExternalEncoding))
        if self.Duration is not None:
            showIndent(outfile, level)
            outfile.write('Duration=model_.Duration(\n')
            self.Duration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ServiceDays is not None:
            showIndent(outfile, level)
            outfile.write('ServiceDays=model_.ServiceDays(\n')
            self.ServiceDays.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Products is not None:
            showIndent(outfile, level)
            outfile.write('Products=model_.Products(\n')
            self.Products.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContextURL is not None:
            showIndent(outfile, level)
            outfile.write('ContextURL=model_.ContextURL(\n')
            self.ContextURL.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
        elif nodeName_ == 'Departure':
            obj_ = Departure.factory()
            obj_.build(child_)
            self.set_Departure(obj_)
        elif nodeName_ == 'Arrival':
            obj_ = Arrival.factory()
            obj_.build(child_)
            self.set_Arrival(obj_)
        elif nodeName_ == 'Transfers':
            Transfers_ = child_.text
            Transfers_ = self.gds_validate_string(Transfers_, node, 'Transfers')
            self.Transfers = Transfers_
        elif nodeName_ == 'Duration':
            class_obj_ = self.get_class_obj_(child_, TimeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Duration(obj_)
        elif nodeName_ == 'ServiceDays':
            obj_ = ServiceDays.factory()
            obj_.build(child_)
            self.set_ServiceDays(obj_)
        elif nodeName_ == 'Products':
            obj_ = Products.factory()
            obj_.build(child_)
            self.set_Products(obj_)
        elif nodeName_ == 'ContextURL':
            obj_ = ContextURL.factory()
            obj_.build(child_)
            self.set_ContextURL(obj_)
# end class Overview


class Products(GeneratedsSuper):
    """The Products section shows the product categories, used in the
    current connection."""
    subclass = None
    superclass = None
    def __init__(self, Product=None):
        if Product is None:
            self.Product = []
        else:
            self.Product = Product
    def factory(*args_, **kwargs_):
        if Products.subclass:
            return Products.subclass(*args_, **kwargs_)
        else:
            return Products(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Product(self): return self.Product
    def set_Product(self, Product): self.Product = Product
    def add_Product(self, value): self.Product.append(value)
    def insert_Product(self, index, value): self.Product[index] = value
    def export(self, outfile, level, namespace_='', name_='Products', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Products')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Products'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Products', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Product_ in self.Product:
            Product_.export(outfile, level, namespace_, name_='Product', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Product
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Products'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Product=[\n')
        level += 1
        for Product_ in self.Product:
            showIndent(outfile, level)
            outfile.write('model_.Product(\n')
            Product_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Product':
            obj_ = Product.factory()
            obj_.build(child_)
            self.Product.append(obj_)
# end class Products


class Product(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cat=None):
        self.cat = _cast(None, cat)
        pass
    def factory(*args_, **kwargs_):
        if Product.subclass:
            return Product.subclass(*args_, **kwargs_)
        else:
            return Product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cat(self): return self.cat
    def set_cat(self, cat): self.cat = cat
    def export(self, outfile, level, namespace_='', name_='Product', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Product')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Product'):
        if self.cat is not None and 'cat' not in already_processed:
            already_processed.append('cat')
            outfile.write(' cat=%s' % (self.gds_format_string(quote_attrib(self.cat).encode(ExternalEncoding), input_name='cat'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Product', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Product'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cat is not None and 'cat' not in already_processed:
            already_processed.append('cat')
            showIndent(outfile, level)
            outfile.write('cat = "%s",\n' % (self.cat,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cat', node)
        if value is not None and 'cat' not in already_processed:
            already_processed.append('cat')
            self.cat = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Product


class ContextURL(GeneratedsSuper):
    """The element ContextURL takes an URL that generates a more detailed
    view of the connection specified in the overview. If you need
    this element please contact us. By default, this element will
    not be available."""
    subclass = None
    superclass = None
    def __init__(self, url=None):
        self.url = _cast(None, url)
        pass
    def factory(*args_, **kwargs_):
        if ContextURL.subclass:
            return ContextURL.subclass(*args_, **kwargs_)
        else:
            return ContextURL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def export(self, outfile, level, namespace_='', name_='ContextURL', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContextURL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContextURL'):
        if self.url is not None and 'url' not in already_processed:
            already_processed.append('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ContextURL', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContextURL'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.append('url')
            showIndent(outfile, level)
            outfile.write('url = "%s",\n' % (self.url,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.append('url')
            self.url = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ContextURL


class ConSectionList(GeneratedsSuper):
    """The ConSectionList is a container for the consections that form the
    connection. A connecton can have a maximum of 12 ConSections.
    Sections of type Walk and Transfer are counted as a ConSection."""
    subclass = None
    superclass = None
    def __init__(self, ConSection=None):
        if ConSection is None:
            self.ConSection = []
        else:
            self.ConSection = ConSection
    def factory(*args_, **kwargs_):
        if ConSectionList.subclass:
            return ConSectionList.subclass(*args_, **kwargs_)
        else:
            return ConSectionList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConSection(self): return self.ConSection
    def set_ConSection(self, ConSection): self.ConSection = ConSection
    def add_ConSection(self, value): self.ConSection.append(value)
    def insert_ConSection(self, index, value): self.ConSection[index] = value
    def export(self, outfile, level, namespace_='', name_='ConSectionList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConSectionList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConSectionList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConSectionList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ConSection_ in self.ConSection:
            ConSection_.export(outfile, level, namespace_, name_='ConSection', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ConSection
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConSectionList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ConSection=[\n')
        level += 1
        for ConSection_ in self.ConSection:
            showIndent(outfile, level)
            outfile.write('model_.ConSection(\n')
            ConSection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConSection':
            obj_ = ConSection.factory()
            obj_.build(child_)
            self.ConSection.append(obj_)
# end class ConSectionList


class ConSection(GeneratedsSuper):
    """A ConSection consists of a Departure an Arrival and an element
    Journey, Walk, Transfer or GisRoute, giving more informations
    about the current ConSection."""
    subclass = None
    superclass = None
    def __init__(self, Departure=None, Journey=None, Walk=None, Transfer=None, GisRoute=None, Arrival=None):
        self.Departure = Departure
        self.Journey = Journey
        self.Walk = Walk
        self.Transfer = Transfer
        self.GisRoute = GisRoute
        self.Arrival = Arrival
    def factory(*args_, **kwargs_):
        if ConSection.subclass:
            return ConSection.subclass(*args_, **kwargs_)
        else:
            return ConSection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Departure(self): return self.Departure
    def set_Departure(self, Departure): self.Departure = Departure
    def get_Journey(self): return self.Journey
    def set_Journey(self, Journey): self.Journey = Journey
    def get_Walk(self): return self.Walk
    def set_Walk(self, Walk): self.Walk = Walk
    def get_Transfer(self): return self.Transfer
    def set_Transfer(self, Transfer): self.Transfer = Transfer
    def get_GisRoute(self): return self.GisRoute
    def set_GisRoute(self, GisRoute): self.GisRoute = GisRoute
    def get_Arrival(self): return self.Arrival
    def set_Arrival(self, Arrival): self.Arrival = Arrival
    def export(self, outfile, level, namespace_='', name_='ConSection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConSection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConSection'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConSection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Departure is not None:
            self.Departure.export(outfile, level, namespace_, name_='Departure', pretty_print=pretty_print)
        if self.Journey is not None:
            self.Journey.export(outfile, level, namespace_, name_='Journey', pretty_print=pretty_print)
        if self.Walk is not None:
            self.Walk.export(outfile, level, namespace_, name_='Walk', pretty_print=pretty_print)
        if self.Transfer is not None:
            self.Transfer.export(outfile, level, namespace_, name_='Transfer', pretty_print=pretty_print)
        if self.GisRoute is not None:
            self.GisRoute.export(outfile, level, namespace_, name_='GisRoute', pretty_print=pretty_print)
        if self.Arrival is not None:
            self.Arrival.export(outfile, level, namespace_, name_='Arrival', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Departure is not None or
            self.Journey is not None or
            self.Walk is not None or
            self.Transfer is not None or
            self.GisRoute is not None or
            self.Arrival is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConSection'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Departure is not None:
            showIndent(outfile, level)
            outfile.write('Departure=model_.Departure(\n')
            self.Departure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Journey is not None:
            showIndent(outfile, level)
            outfile.write('Journey=model_.Journey(\n')
            self.Journey.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Walk is not None:
            showIndent(outfile, level)
            outfile.write('Walk=model_.Walk(\n')
            self.Walk.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Transfer is not None:
            showIndent(outfile, level)
            outfile.write('Transfer=model_.Transfer(\n')
            self.Transfer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.GisRoute is not None:
            showIndent(outfile, level)
            outfile.write('GisRoute=model_.GisRoute(\n')
            self.GisRoute.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Arrival is not None:
            showIndent(outfile, level)
            outfile.write('Arrival=model_.Arrival(\n')
            self.Arrival.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Departure':
            obj_ = Departure.factory()
            obj_.build(child_)
            self.set_Departure(obj_)
        elif nodeName_ == 'Journey':
            obj_ = Journey.factory()
            obj_.build(child_)
            self.set_Journey(obj_)
        elif nodeName_ == 'Walk':
            obj_ = Walk.factory()
            obj_.build(child_)
            self.set_Walk(obj_)
        elif nodeName_ == 'Transfer':
            obj_ = Transfer.factory()
            obj_.build(child_)
            self.set_Transfer(obj_)
        elif nodeName_ == 'GisRoute':
            obj_ = GisRoute.factory()
            obj_.build(child_)
            self.set_GisRoute(obj_)
        elif nodeName_ == 'Arrival':
            obj_ = Arrival.factory()
            obj_.build(child_)
            self.set_Arrival(obj_)
# end class ConSection


class Departure(GeneratedsSuper):
    """The departure location of a ConSection"""
    subclass = None
    superclass = None
    def __init__(self, BasicStop=None):
        self.BasicStop = BasicStop
    def factory(*args_, **kwargs_):
        if Departure.subclass:
            return Departure.subclass(*args_, **kwargs_)
        else:
            return Departure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BasicStop(self): return self.BasicStop
    def set_BasicStop(self, BasicStop): self.BasicStop = BasicStop
    def export(self, outfile, level, namespace_='', name_='Departure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Departure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Departure'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Departure', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BasicStop is not None:
            self.BasicStop.export(outfile, level, namespace_, name_='BasicStop', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.BasicStop is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Departure'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BasicStop is not None:
            showIndent(outfile, level)
            outfile.write('BasicStop=model_.BasicStop(\n')
            self.BasicStop.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BasicStop':
            obj_ = BasicStop.factory()
            obj_.build(child_)
            self.set_BasicStop(obj_)
# end class Departure


class Arrival(GeneratedsSuper):
    """The arrival location of a ConSection"""
    subclass = None
    superclass = None
    def __init__(self, BasicStop=None):
        self.BasicStop = BasicStop
    def factory(*args_, **kwargs_):
        if Arrival.subclass:
            return Arrival.subclass(*args_, **kwargs_)
        else:
            return Arrival(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BasicStop(self): return self.BasicStop
    def set_BasicStop(self, BasicStop): self.BasicStop = BasicStop
    def export(self, outfile, level, namespace_='', name_='Arrival', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Arrival')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Arrival'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Arrival', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BasicStop is not None:
            self.BasicStop.export(outfile, level, namespace_, name_='BasicStop', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.BasicStop is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Arrival'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BasicStop is not None:
            showIndent(outfile, level)
            outfile.write('BasicStop=model_.BasicStop(\n')
            self.BasicStop.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BasicStop':
            obj_ = BasicStop.factory()
            obj_.build(child_)
            self.set_BasicStop(obj_)
# end class Arrival


class BasicStop(GeneratedsSuper):
    """The element BasicStop represents a Location, as a part of the
    current ConSection. It contains a Location (Station, Address,
    Poi) together with the arrival and departure times at this
    location, as well as some other information like platforms."""
    subclass = None
    superclass = None
    def __init__(self, index=None, type_='NORMAL', Address=None, Poi=None, Station=None, Arr=None, Dep=None, StopPrognosis=None):
        self.index = _cast(int, index)
        self.type_ = _cast(None, type_)
        self.Address = Address
        self.Poi = Poi
        self.Station = Station
        self.Arr = Arr
        self.Dep = Dep
        self.StopPrognosis = StopPrognosis
    def factory(*args_, **kwargs_):
        if BasicStop.subclass:
            return BasicStop.subclass(*args_, **kwargs_)
        else:
            return BasicStop(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_Poi(self): return self.Poi
    def set_Poi(self, Poi): self.Poi = Poi
    def get_Station(self): return self.Station
    def set_Station(self, Station): self.Station = Station
    def get_Arr(self): return self.Arr
    def set_Arr(self, Arr): self.Arr = Arr
    def get_Dep(self): return self.Dep
    def set_Dep(self, Dep): self.Dep = Dep
    def get_StopPrognosis(self): return self.StopPrognosis
    def set_StopPrognosis(self, StopPrognosis): self.StopPrognosis = StopPrognosis
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='BasicStop', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasicStop')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BasicStop'):
        if self.index is not None and 'index' not in already_processed:
            already_processed.append('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BasicStop', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        if self.Poi is not None:
            self.Poi.export(outfile, level, namespace_, name_='Poi', pretty_print=pretty_print)
        if self.Station is not None:
            self.Station.export(outfile, level, namespace_, name_='Station', pretty_print=pretty_print)
        if self.Arr is not None:
            self.Arr.export(outfile, level, namespace_, name_='Arr', pretty_print=pretty_print)
        if self.Dep is not None:
            self.Dep.export(outfile, level, namespace_, name_='Dep', pretty_print=pretty_print)
        if self.StopPrognosis is not None:
            self.StopPrognosis.export(outfile, level, namespace_, name_='StopPrognosis', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Address is not None or
            self.Poi is not None or
            self.Station is not None or
            self.Arr is not None or
            self.Dep is not None or
            self.StopPrognosis is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BasicStop'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.index is not None and 'index' not in already_processed:
            already_processed.append('index')
            showIndent(outfile, level)
            outfile.write('index = %d,\n' % (self.index,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=model_.Address(\n')
            self.Address.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Poi is not None:
            showIndent(outfile, level)
            outfile.write('Poi=model_.Poi(\n')
            self.Poi.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Station is not None:
            showIndent(outfile, level)
            outfile.write('Station=model_.Station(\n')
            self.Station.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Arr is not None:
            showIndent(outfile, level)
            outfile.write('Arr=model_.Arr(\n')
            self.Arr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dep is not None:
            showIndent(outfile, level)
            outfile.write('Dep=model_.Dep(\n')
            self.Dep.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StopPrognosis is not None:
            showIndent(outfile, level)
            outfile.write('StopPrognosis=model_.StopPrognosisType(\n')
            self.StopPrognosis.exportLiteral(outfile, level, name_='StopPrognosis')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.append('index')
            try:
                self.index = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_Address(obj_)
        elif nodeName_ == 'Poi':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_Poi(obj_)
        elif nodeName_ == 'Station':
            obj_ = StationType.factory()
            obj_.build(child_)
            self.set_Station(obj_)
        elif nodeName_ == 'Arr':
            obj_ = ArrDepType.factory()
            obj_.build(child_)
            self.set_Arr(obj_)
        elif nodeName_ == 'Dep':
            obj_ = ArrDepType.factory()
            obj_.build(child_)
            self.set_Dep(obj_)
        elif nodeName_ == 'StopPrognosis':
            obj_ = StopPrognosisType.factory()
            obj_.build(child_)
            self.set_StopPrognosis(obj_)
# end class BasicStop


class Platform(GeneratedsSuper):
    """The element Platform supplies information about the Departure- and
    Arrivalplatform at a Station. The maximum length of this string
    is 8 characters."""
    subclass = None
    superclass = None
    def __init__(self, Text=None):
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if Platform.subclass:
            return Platform.subclass(*args_, **kwargs_)
        else:
            return Platform(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def export(self, outfile, level, namespace_='', name_='Platform', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Platform')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Platform'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Platform', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Platform'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class Platform


class ArrDepType(TimeType):
    subclass = None
    superclass = TimeType
    def __init__(self, Time=None, getIn='YES', getOut='YES', Platform=None):
        super(ArrDepType, self).__init__(Time, )
        self.getIn = _cast(None, getIn)
        self.getOut = _cast(None, getOut)
        self.Platform = Platform
    def factory(*args_, **kwargs_):
        if ArrDepType.subclass:
            return ArrDepType.subclass(*args_, **kwargs_)
        else:
            return ArrDepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Platform(self): return self.Platform
    def set_Platform(self, Platform): self.Platform = Platform
    def get_getIn(self): return self.getIn
    def set_getIn(self, getIn): self.getIn = getIn
    def get_getOut(self): return self.getOut
    def set_getOut(self, getOut): self.getOut = getOut
    def export(self, outfile, level, namespace_='', name_='ArrDepType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArrDepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ArrDepType'):
        super(ArrDepType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ArrDepType')
        if self.getIn is not None and 'getIn' not in already_processed:
            already_processed.append('getIn')
            outfile.write(' getIn=%s' % (self.gds_format_string(quote_attrib(self.getIn).encode(ExternalEncoding), input_name='getIn'), ))
        if self.getOut is not None and 'getOut' not in already_processed:
            already_processed.append('getOut')
            outfile.write(' getOut=%s' % (self.gds_format_string(quote_attrib(self.getOut).encode(ExternalEncoding), input_name='getOut'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ArrDepType', fromsubclass_=False, pretty_print=True):
        super(ArrDepType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Platform is not None:
            self.Platform.export(outfile, level, namespace_, name_='Platform', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Platform is not None or
            super(ArrDepType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArrDepType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.getIn is not None and 'getIn' not in already_processed:
            already_processed.append('getIn')
            showIndent(outfile, level)
            outfile.write('getIn = "%s",\n' % (self.getIn,))
        if self.getOut is not None and 'getOut' not in already_processed:
            already_processed.append('getOut')
            showIndent(outfile, level)
            outfile.write('getOut = "%s",\n' % (self.getOut,))
        super(ArrDepType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ArrDepType, self).exportLiteralChildren(outfile, level, name_)
        if self.Platform is not None:
            showIndent(outfile, level)
            outfile.write('Platform=model_.Platform(\n')
            self.Platform.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('getIn', node)
        if value is not None and 'getIn' not in already_processed:
            already_processed.append('getIn')
            self.getIn = value
            self.getIn = ' '.join(self.getIn.split())
        value = find_attr_value_('getOut', node)
        if value is not None and 'getOut' not in already_processed:
            already_processed.append('getOut')
            self.getOut = value
            self.getOut = ' '.join(self.getOut.split())
        super(ArrDepType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Platform':
            obj_ = Platform.factory()
            obj_.build(child_)
            self.set_Platform(obj_)
        super(ArrDepType, self).buildChildren(child_, node, nodeName_, True)
# end class ArrDepType


class Journey(GeneratedsSuper):
    """The element Journey contains the List with the JourneyAttributes
    valid for the current ConSection, as well as (optionally) a
    PassList containing extended Information about the passed
    stations."""
    subclass = None
    superclass = None
    def __init__(self, JHandle=None, JourneyAttributeList=None, PassList=None, JProg=None):
        self.JHandle = JHandle
        self.JourneyAttributeList = JourneyAttributeList
        self.PassList = PassList
        self.JProg = JProg
    def factory(*args_, **kwargs_):
        if Journey.subclass:
            return Journey.subclass(*args_, **kwargs_)
        else:
            return Journey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_JHandle(self): return self.JHandle
    def set_JHandle(self, JHandle): self.JHandle = JHandle
    def get_JourneyAttributeList(self): return self.JourneyAttributeList
    def set_JourneyAttributeList(self, JourneyAttributeList): self.JourneyAttributeList = JourneyAttributeList
    def get_PassList(self): return self.PassList
    def set_PassList(self, PassList): self.PassList = PassList
    def get_JProg(self): return self.JProg
    def set_JProg(self, JProg): self.JProg = JProg
    def export(self, outfile, level, namespace_='', name_='Journey', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Journey')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Journey'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Journey', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.JHandle is not None:
            self.JHandle.export(outfile, level, namespace_, name_='JHandle', pretty_print=pretty_print)
        if self.JourneyAttributeList is not None:
            self.JourneyAttributeList.export(outfile, level, namespace_, name_='JourneyAttributeList', pretty_print=pretty_print)
        if self.PassList is not None:
            self.PassList.export(outfile, level, namespace_, name_='PassList', pretty_print=pretty_print)
        if self.JProg is not None:
            self.JProg.export(outfile, level, namespace_, name_='JProg', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.JHandle is not None or
            self.JourneyAttributeList is not None or
            self.PassList is not None or
            self.JProg is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Journey'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.JHandle is not None:
            showIndent(outfile, level)
            outfile.write('JHandle=model_.JHandle(\n')
            self.JHandle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JourneyAttributeList is not None:
            showIndent(outfile, level)
            outfile.write('JourneyAttributeList=model_.JourneyAttributeList(\n')
            self.JourneyAttributeList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PassList is not None:
            showIndent(outfile, level)
            outfile.write('PassList=model_.PassList(\n')
            self.PassList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JProg is not None:
            showIndent(outfile, level)
            outfile.write('JProg=model_.JProg(\n')
            self.JProg.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'JHandle':
            obj_ = JHandle.factory()
            obj_.build(child_)
            self.set_JHandle(obj_)
        elif nodeName_ == 'JourneyAttributeList':
            obj_ = JourneyAttributeList.factory()
            obj_.build(child_)
            self.set_JourneyAttributeList(obj_)
        elif nodeName_ == 'PassList':
            obj_ = PassList.factory()
            obj_.build(child_)
            self.set_PassList(obj_)
        elif nodeName_ == 'JProg':
            obj_ = JProg.factory()
            obj_.build(child_)
            self.set_JProg(obj_)
# end class Journey


class Walk(GeneratedsSuper):
    """A Walk is an unrouted transition with a duration of max. 15
    minutes.Length of the walk in meters. (linear distance)"""
    subclass = None
    superclass = None
    def __init__(self, length=None, Duration=None, Distance=None, JourneyAttributeList=None):
        self.length = _cast(int, length)
        self.Duration = Duration
        self.Distance = Distance
        self.JourneyAttributeList = JourneyAttributeList
    def factory(*args_, **kwargs_):
        if Walk.subclass:
            return Walk.subclass(*args_, **kwargs_)
        else:
            return Walk(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Duration(self): return self.Duration
    def set_Duration(self, Duration): self.Duration = Duration
    def get_Distance(self): return self.Distance
    def set_Distance(self, Distance): self.Distance = Distance
    def get_JourneyAttributeList(self): return self.JourneyAttributeList
    def set_JourneyAttributeList(self, JourneyAttributeList): self.JourneyAttributeList = JourneyAttributeList
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def export(self, outfile, level, namespace_='', name_='Walk', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Walk')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Walk'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
    def exportChildren(self, outfile, level, namespace_='', name_='Walk', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Duration is not None:
            self.Duration.export(outfile, level, namespace_, name_='Duration', pretty_print=pretty_print)
        if self.Distance is not None:
            self.Distance.export(outfile, level, namespace_, name_='Distance', pretty_print=pretty_print)
        if self.JourneyAttributeList is not None:
            self.JourneyAttributeList.export(outfile, level, namespace_, name_='JourneyAttributeList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Duration is not None or
            self.Distance is not None or
            self.JourneyAttributeList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Walk'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            showIndent(outfile, level)
            outfile.write('length = %d,\n' % (self.length,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Duration is not None:
            showIndent(outfile, level)
            outfile.write('Duration=model_.Duration(\n')
            self.Duration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Distance is not None:
            showIndent(outfile, level)
            outfile.write('Distance=model_.Distance(\n')
            self.Distance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JourneyAttributeList is not None:
            showIndent(outfile, level)
            outfile.write('JourneyAttributeList=model_.JourneyAttributeList(\n')
            self.JourneyAttributeList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.append('length')
            try:
                self.length = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Duration':
            class_obj_ = self.get_class_obj_(child_, TimeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Duration(obj_)
        elif nodeName_ == 'Distance':
            obj_ = Distance.factory()
            obj_.build(child_)
            self.set_Distance(obj_)
        elif nodeName_ == 'JourneyAttributeList':
            obj_ = JourneyAttributeList.factory()
            obj_.build(child_)
            self.set_JourneyAttributeList(obj_)
# end class Walk


class Distance(GeneratedsSuper):
    """Distance in meters."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Distance.subclass:
            return Distance.subclass(*args_, **kwargs_)
        else:
            return Distance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Distance', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Distance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Distance'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Distance', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Distance'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Distance


class Transfer(GeneratedsSuper):
    """A Transfer is an unrouted transition with a duration of more than 15
    minutes.Length of the walk in meters. (linear distance)"""
    subclass = None
    superclass = None
    def __init__(self, length=None, Duration=None, JourneyAttributeList=None):
        self.length = _cast(int, length)
        self.Duration = Duration
        self.JourneyAttributeList = JourneyAttributeList
    def factory(*args_, **kwargs_):
        if Transfer.subclass:
            return Transfer.subclass(*args_, **kwargs_)
        else:
            return Transfer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Duration(self): return self.Duration
    def set_Duration(self, Duration): self.Duration = Duration
    def get_JourneyAttributeList(self): return self.JourneyAttributeList
    def set_JourneyAttributeList(self, JourneyAttributeList): self.JourneyAttributeList = JourneyAttributeList
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def export(self, outfile, level, namespace_='', name_='Transfer', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Transfer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Transfer'):
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
    def exportChildren(self, outfile, level, namespace_='', name_='Transfer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Duration is not None:
            self.Duration.export(outfile, level, namespace_, name_='Duration', pretty_print=pretty_print)
        if self.JourneyAttributeList is not None:
            self.JourneyAttributeList.export(outfile, level, namespace_, name_='JourneyAttributeList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Duration is not None or
            self.JourneyAttributeList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Transfer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            showIndent(outfile, level)
            outfile.write('length = %d,\n' % (self.length,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Duration is not None:
            showIndent(outfile, level)
            outfile.write('Duration=model_.Duration(\n')
            self.Duration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JourneyAttributeList is not None:
            showIndent(outfile, level)
            outfile.write('JourneyAttributeList=model_.JourneyAttributeList(\n')
            self.JourneyAttributeList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.append('length')
            try:
                self.length = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Duration':
            class_obj_ = self.get_class_obj_(child_, TimeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Duration(obj_)
        elif nodeName_ == 'JourneyAttributeList':
            obj_ = JourneyAttributeList.factory()
            obj_.build(child_)
            self.set_JourneyAttributeList(obj_)
# end class Transfer


class GisRoute(GeneratedsSuper):
    """A GisRoute is an externally routed consection."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, Duration=None, Distance=None, JourneyAttributeList=None):
        self.type_ = _cast(None, type_)
        self.Duration = Duration
        self.Distance = Distance
        self.JourneyAttributeList = JourneyAttributeList
    def factory(*args_, **kwargs_):
        if GisRoute.subclass:
            return GisRoute.subclass(*args_, **kwargs_)
        else:
            return GisRoute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Duration(self): return self.Duration
    def set_Duration(self, Duration): self.Duration = Duration
    def get_Distance(self): return self.Distance
    def set_Distance(self, Distance): self.Distance = Distance
    def get_JourneyAttributeList(self): return self.JourneyAttributeList
    def set_JourneyAttributeList(self, JourneyAttributeList): self.JourneyAttributeList = JourneyAttributeList
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='GisRoute', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GisRoute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GisRoute'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GisRoute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Duration is not None:
            self.Duration.export(outfile, level, namespace_, name_='Duration', pretty_print=pretty_print)
        if self.Distance is not None:
            self.Distance.export(outfile, level, namespace_, name_='Distance', pretty_print=pretty_print)
        if self.JourneyAttributeList is not None:
            self.JourneyAttributeList.export(outfile, level, namespace_, name_='JourneyAttributeList', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Duration is not None or
            self.Distance is not None or
            self.JourneyAttributeList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GisRoute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Duration is not None:
            showIndent(outfile, level)
            outfile.write('Duration=model_.Duration(\n')
            self.Duration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Distance is not None:
            showIndent(outfile, level)
            outfile.write('Distance=model_.Distance(\n')
            self.Distance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.JourneyAttributeList is not None:
            showIndent(outfile, level)
            outfile.write('JourneyAttributeList=model_.JourneyAttributeList(\n')
            self.JourneyAttributeList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Duration':
            class_obj_ = self.get_class_obj_(child_, TimeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Duration(obj_)
        elif nodeName_ == 'Distance':
            obj_ = Distance.factory()
            obj_.build(child_)
            self.set_Distance(obj_)
        elif nodeName_ == 'JourneyAttributeList':
            obj_ = JourneyAttributeList.factory()
            obj_.build(child_)
            self.set_JourneyAttributeList(obj_)
# end class GisRoute


class PassList(GeneratedsSuper):
    """The element PassList contains informations about the passed stops of
    the current ConSection. It contains a sequence of BasicStop
    elements"""
    subclass = None
    superclass = None
    def __init__(self, BasicStop=None):
        if BasicStop is None:
            self.BasicStop = []
        else:
            self.BasicStop = BasicStop
    def factory(*args_, **kwargs_):
        if PassList.subclass:
            return PassList.subclass(*args_, **kwargs_)
        else:
            return PassList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BasicStop(self): return self.BasicStop
    def set_BasicStop(self, BasicStop): self.BasicStop = BasicStop
    def add_BasicStop(self, value): self.BasicStop.append(value)
    def insert_BasicStop(self, index, value): self.BasicStop[index] = value
    def export(self, outfile, level, namespace_='', name_='PassList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PassList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PassList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PassList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BasicStop_ in self.BasicStop:
            BasicStop_.export(outfile, level, namespace_, name_='BasicStop', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.BasicStop
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PassList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('BasicStop=[\n')
        level += 1
        for BasicStop_ in self.BasicStop:
            showIndent(outfile, level)
            outfile.write('model_.BasicStop(\n')
            BasicStop_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BasicStop':
            obj_ = BasicStop.factory()
            obj_.build(child_)
            self.BasicStop.append(obj_)
# end class PassList


class CommentList(GeneratedsSuper):
    """The CommentList may contain additional informations for the current
    connection/consection. This feature is not used in the current
    version of the interface."""
    subclass = None
    superclass = None
    def __init__(self, Comment=None):
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CommentList.subclass:
            return CommentList.subclass(*args_, **kwargs_)
        else:
            return CommentList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self): return self.Comment
    def set_Comment(self, Comment): self.Comment = Comment
    def add_Comment(self, value): self.Comment.append(value)
    def insert_Comment(self, index, value): self.Comment[index] = value
    def export(self, outfile, level, namespace_='', name_='CommentList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommentList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommentList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommentList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespace_, name_='Comment', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Comment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CommentList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Comment=[\n')
        level += 1
        for Comment_ in self.Comment:
            showIndent(outfile, level)
            outfile.write('model_.Comment(\n')
            Comment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory()
            obj_.build(child_)
            self.Comment.append(obj_)
# end class CommentList


class Comment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, Text=None):
        self.id = _cast(None, id)
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if Comment.subclass:
            return Comment.subclass(*args_, **kwargs_)
        else:
            return Comment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='Comment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Comment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Comment'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Comment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Comment'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class Comment


class JHandle(GeneratedsSuper):
    """A journey handle can be taken subsequent journey requests. Can be
    taken as is, and placed in the corresponding JourneyReq"""
    subclass = None
    superclass = None
    def __init__(self, cycle=None, puic=None, tNr=None):
        self.cycle = _cast(None, cycle)
        self.puic = _cast(None, puic)
        self.tNr = _cast(None, tNr)
        pass
    def factory(*args_, **kwargs_):
        if JHandle.subclass:
            return JHandle.subclass(*args_, **kwargs_)
        else:
            return JHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cycle(self): return self.cycle
    def set_cycle(self, cycle): self.cycle = cycle
    def get_puic(self): return self.puic
    def set_puic(self, puic): self.puic = puic
    def get_tNr(self): return self.tNr
    def set_tNr(self, tNr): self.tNr = tNr
    def export(self, outfile, level, namespace_='', name_='JHandle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JHandle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JHandle'):
        if self.cycle is not None and 'cycle' not in already_processed:
            already_processed.append('cycle')
            outfile.write(' cycle=%s' % (self.gds_format_string(quote_attrib(self.cycle).encode(ExternalEncoding), input_name='cycle'), ))
        if self.puic is not None and 'puic' not in already_processed:
            already_processed.append('puic')
            outfile.write(' puic=%s' % (self.gds_format_string(quote_attrib(self.puic).encode(ExternalEncoding), input_name='puic'), ))
        if self.tNr is not None and 'tNr' not in already_processed:
            already_processed.append('tNr')
            outfile.write(' tNr=%s' % (self.gds_format_string(quote_attrib(self.tNr).encode(ExternalEncoding), input_name='tNr'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='JHandle', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JHandle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.cycle is not None and 'cycle' not in already_processed:
            already_processed.append('cycle')
            showIndent(outfile, level)
            outfile.write('cycle = "%s",\n' % (self.cycle,))
        if self.puic is not None and 'puic' not in already_processed:
            already_processed.append('puic')
            showIndent(outfile, level)
            outfile.write('puic = "%s",\n' % (self.puic,))
        if self.tNr is not None and 'tNr' not in already_processed:
            already_processed.append('tNr')
            showIndent(outfile, level)
            outfile.write('tNr = "%s",\n' % (self.tNr,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cycle', node)
        if value is not None and 'cycle' not in already_processed:
            already_processed.append('cycle')
            self.cycle = value
        value = find_attr_value_('puic', node)
        if value is not None and 'puic' not in already_processed:
            already_processed.append('puic')
            self.puic = value
        value = find_attr_value_('tNr', node)
        if value is not None and 'tNr' not in already_processed:
            already_processed.append('tNr')
            self.tNr = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class JHandle


class AltConList(GeneratedsSuper):
    """The AltConList may contain references to alternative connections
    (realtime)."""
    subclass = None
    superclass = None
    def __init__(self, id=None):
        if id is None:
            self.id = []
        else:
            self.id = id
    def factory(*args_, **kwargs_):
        if AltConList.subclass:
            return AltConList.subclass(*args_, **kwargs_)
        else:
            return AltConList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def add_id(self, value): self.id.append(value)
    def insert_id(self, index, value): self.id[index] = value
    def export(self, outfile, level, namespace_='', name_='AltConList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AltConList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AltConList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AltConList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for id_ in self.id:
            id_.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.id
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AltConList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('id=[\n')
        level += 1
        for id_ in self.id:
            showIndent(outfile, level)
            outfile.write('model_.xs_IDREF(\n')
            id_.exportLiteral(outfile, level, name_='xs:IDREF')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            obj_ = xs_IDREF.factory()
            obj_.build(child_)
            self.id.append(obj_)
# end class AltConList


class RtStateList(GeneratedsSuper):
    """Contains a list of information regarding the realtime status of the
    connection"""
    subclass = None
    superclass = None
    def __init__(self, RtState=None):
        if RtState is None:
            self.RtState = []
        else:
            self.RtState = RtState
    def factory(*args_, **kwargs_):
        if RtStateList.subclass:
            return RtStateList.subclass(*args_, **kwargs_)
        else:
            return RtStateList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RtState(self): return self.RtState
    def set_RtState(self, RtState): self.RtState = RtState
    def add_RtState(self, value): self.RtState.append(value)
    def insert_RtState(self, index, value): self.RtState[index] = value
    def export(self, outfile, level, namespace_='', name_='RtStateList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RtStateList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RtStateList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RtStateList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RtState_ in self.RtState:
            RtState_.export(outfile, level, namespace_, name_='RtState', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.RtState
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RtStateList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RtState=[\n')
        level += 1
        for RtState_ in self.RtState:
            showIndent(outfile, level)
            outfile.write('model_.RtState(\n')
            RtState_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RtState':
            obj_ = RtState.factory()
            obj_.build(child_)
            self.RtState.append(obj_)
# end class RtStateList


class RtState(GeneratedsSuper):
    """Values can be: HAS_DELAYINFO: connection is ridable, delayinfos are
    available; HAS_ALTERNATIVE: for this connection is an
    alternative connection available; IS_ALTERNATIVE: this
    connection is an alternative connection; WARNING_TRANSFER:
    transfer not possible, because train is to late;
    WARNING_CONNECTION_NOT_RIDABLE: connection not ridable;"""
    subclass = None
    superclass = None
    def __init__(self, value=None):
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if RtState.subclass:
            return RtState.subclass(*args_, **kwargs_)
        else:
            return RtState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='RtState', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RtState')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RtState'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RtState', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RtState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RtState


class JProg(GeneratedsSuper):
    """Train based realtime information"""
    subclass = None
    superclass = None
    def __init__(self, JStatus=None):
        self.JStatus = JStatus
    def factory(*args_, **kwargs_):
        if JProg.subclass:
            return JProg.subclass(*args_, **kwargs_)
        else:
            return JProg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_JStatus(self): return self.JStatus
    def set_JStatus(self, JStatus): self.JStatus = JStatus
    def export(self, outfile, level, namespace_='', name_='JProg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JProg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JProg'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JProg', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.JStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJStatus>%s</%sJStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.JStatus).encode(ExternalEncoding), input_name='JStatus'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.JStatus is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JProg'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.JStatus is not None:
            showIndent(outfile, level)
            outfile.write('JStatus=%s,\n' % quote_python(self.JStatus).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'JStatus':
            JStatus_ = child_.text
            JStatus_ = self.gds_validate_string(JStatus_, node, 'JStatus')
            self.JStatus = JStatus_
# end class JProg


class JStatus(GeneratedsSuper):
    """Possible values are: FAILURE - train failure via real time. NEW or
    ADDITIONAL - identifies addtional train. REPLACEMENT -
    identifies alternative train. REDIRECTION - one or several
    additional stops and/or contrary some stops can not be served.
    PARTIAL_FAILURE - a part of a track can not be served.
    PARTIAL_ACTIVATION , REDIRECTION_FAILURE,
    REPLACEMENT_REDIRECTION are reserverd for future use. SCHEDULED
    - train is in time"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if JStatus.subclass:
            return JStatus.subclass(*args_, **kwargs_)
        else:
            return JStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='JStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JStatus', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JStatus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class JStatus


class AnnoText(GeneratedsSuper):
    """Text message"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if AnnoText.subclass:
            return AnnoText.subclass(*args_, **kwargs_)
        else:
            return AnnoText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='AnnoText', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnoText')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnnoText'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AnnoText', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AnnoText'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AnnoText


class Attribute(GeneratedsSuper):
    """Attributes describe the characteristics of a ConSection, such as the
    name of the means of transport, the category of the means of
    transport, general attributes like Bord Restaurant, Reservation
    required and other characteristics. For a detailed description
    of the different attributes see the attribute type. Some types
    of attributes can have different attribute variants (NORMAL,
    SHORT and LONG), containing different Levels of information."""
    subclass = None
    superclass = None
    def __init__(self, priority=None, code=None, type_='NORMAL', AttributeVariant=None):
        self.priority = _cast(int, priority)
        self.code = _cast(None, code)
        self.type_ = _cast(None, type_)
        if AttributeVariant is None:
            self.AttributeVariant = []
        else:
            self.AttributeVariant = AttributeVariant
    def factory(*args_, **kwargs_):
        if Attribute.subclass:
            return Attribute.subclass(*args_, **kwargs_)
        else:
            return Attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AttributeVariant(self): return self.AttributeVariant
    def set_AttributeVariant(self, AttributeVariant): self.AttributeVariant = AttributeVariant
    def add_AttributeVariant(self, value): self.AttributeVariant.append(value)
    def insert_AttributeVariant(self, index, value): self.AttributeVariant[index] = value
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='Attribute', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Attribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Attribute'):
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.append('priority')
            outfile.write(' priority="%s"' % self.gds_format_integer(self.priority, input_name='priority'))
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            outfile.write(' code=%s' % (self.gds_format_string(quote_attrib(self.code).encode(ExternalEncoding), input_name='code'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Attribute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AttributeVariant_ in self.AttributeVariant:
            AttributeVariant_.export(outfile, level, namespace_, name_='AttributeVariant', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.AttributeVariant
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Attribute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.append('priority')
            showIndent(outfile, level)
            outfile.write('priority = %d,\n' % (self.priority,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.append('code')
            showIndent(outfile, level)
            outfile.write('code = "%s",\n' % (self.code,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AttributeVariant=[\n')
        level += 1
        for AttributeVariant_ in self.AttributeVariant:
            showIndent(outfile, level)
            outfile.write('model_.AttributeVariant(\n')
            AttributeVariant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.append('priority')
            try:
                self.priority = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.append('code')
            self.code = value
            self.code = ' '.join(self.code.split())
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AttributeVariant':
            obj_ = AttributeVariant.factory()
            obj_.build(child_)
            self.AttributeVariant.append(obj_)
# end class Attribute


class AttributeVariant(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_='NORMAL', Text=None):
        self.type_ = _cast(None, type_)
        if Text is None:
            self.Text = []
        else:
            self.Text = Text
    def factory(*args_, **kwargs_):
        if AttributeVariant.subclass:
            return AttributeVariant.subclass(*args_, **kwargs_)
        else:
            return AttributeVariant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def add_Text(self, value): self.Text.append(value)
    def insert_Text(self, index, value): self.Text[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='AttributeVariant', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeVariant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeVariant'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeVariant', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Text_ in self.Text:
            Text_.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Text
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AttributeVariant'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Text=[\n')
        level += 1
        for Text_ in self.Text:
            showIndent(outfile, level)
            outfile.write('model_.Text(\n')
            Text_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.Text.append(obj_)
# end class AttributeVariant


class JourneyAttributeList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, JourneyAttribute=None):
        if JourneyAttribute is None:
            self.JourneyAttribute = []
        else:
            self.JourneyAttribute = JourneyAttribute
    def factory(*args_, **kwargs_):
        if JourneyAttributeList.subclass:
            return JourneyAttributeList.subclass(*args_, **kwargs_)
        else:
            return JourneyAttributeList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_JourneyAttribute(self): return self.JourneyAttribute
    def set_JourneyAttribute(self, JourneyAttribute): self.JourneyAttribute = JourneyAttribute
    def add_JourneyAttribute(self, value): self.JourneyAttribute.append(value)
    def insert_JourneyAttribute(self, index, value): self.JourneyAttribute[index] = value
    def export(self, outfile, level, namespace_='', name_='JourneyAttributeList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JourneyAttributeList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JourneyAttributeList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='JourneyAttributeList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for JourneyAttribute_ in self.JourneyAttribute:
            JourneyAttribute_.export(outfile, level, namespace_, name_='JourneyAttribute', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.JourneyAttribute
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JourneyAttributeList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('JourneyAttribute=[\n')
        level += 1
        for JourneyAttribute_ in self.JourneyAttribute:
            showIndent(outfile, level)
            outfile.write('model_.JourneyAttribute(\n')
            JourneyAttribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'JourneyAttribute':
            obj_ = JourneyAttribute.factory()
            obj_.build(child_)
            self.JourneyAttribute.append(obj_)
# end class JourneyAttributeList


class JourneyAttribute(GeneratedsSuper):
    """A JourneyAttribute contains an element Attribute as well as validity
    informations for this attribute. An attribute must not be valid
    for the whole ConSection and it must not be valid at all the
    ServiceDays of the connection. So the JourneyAttribute can take
    two attributes from and to, specifying an index into the
    PassList. Every BasicStop within a PassList has an attribute
    index. The Attribute is valid from the BasicStop with the index
    matching the index given in the attribute from, to the BasicStop
    with the index matching the index given in the attribute to. The
    element SeviceDays specifies the days were the Attribute is
    valid. if the element ServiceDays is not given, the attribute is
    valid at all the servicedays of the connection. The restriction
    of the ServiceDays of an Attribute is not used at the moment,
    but may be activated in later versions of this interface."""
    subclass = None
    superclass = None
    def __init__(self, to=None, fromxx=None, Attribute=None, ServiceDays=None):
        self.to = _cast(int, to)
        self.fromxx = _cast(int, fromxx)
        self.Attribute = Attribute
        self.ServiceDays = ServiceDays
    def factory(*args_, **kwargs_):
        if JourneyAttribute.subclass:
            return JourneyAttribute.subclass(*args_, **kwargs_)
        else:
            return JourneyAttribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_ServiceDays(self): return self.ServiceDays
    def set_ServiceDays(self, ServiceDays): self.ServiceDays = ServiceDays
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_from(self): return self.fromxx
    def set_from(self, fromxx): self.fromxx = fromxx
    def export(self, outfile, level, namespace_='', name_='JourneyAttribute', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JourneyAttribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='JourneyAttribute'):
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            outfile.write(' to="%s"' % self.gds_format_integer(self.to, input_name='to'))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            outfile.write(' from="%s"' % self.gds_format_integer(self.fromxx, input_name='from'))
    def exportChildren(self, outfile, level, namespace_='', name_='JourneyAttribute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        if self.ServiceDays is not None:
            self.ServiceDays.export(outfile, level, namespace_, name_='ServiceDays', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Attribute is not None or
            self.ServiceDays is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='JourneyAttribute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.to is not None and 'to' not in already_processed:
            already_processed.append('to')
            showIndent(outfile, level)
            outfile.write('to = %d,\n' % (self.to,))
        if self.fromxx is not None and 'fromxx' not in already_processed:
            already_processed.append('fromxx')
            showIndent(outfile, level)
            outfile.write('fromxx = %d,\n' % (self.fromxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.Attribute(\n')
            self.Attribute.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ServiceDays is not None:
            showIndent(outfile, level)
            outfile.write('ServiceDays=model_.ServiceDays(\n')
            self.ServiceDays.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.append('to')
            try:
                self.to = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.append('from')
            try:
                self.fromxx = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = Attribute.factory()
            obj_.build(child_)
            self.set_Attribute(obj_)
        elif nodeName_ == 'ServiceDays':
            obj_ = ServiceDays.factory()
            obj_.build(child_)
            self.set_ServiceDays(obj_)
# end class JourneyAttribute


class IList(GeneratedsSuper):
    """The InfoList may contain announcements (HIM messages) for the
    current connection."""
    subclass = None
    superclass = None
    def __init__(self, I=None):
        if I is None:
            self.I = []
        else:
            self.I = I
    def factory(*args_, **kwargs_):
        if IList.subclass:
            return IList.subclass(*args_, **kwargs_)
        else:
            return IList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_I(self): return self.I
    def set_I(self, I): self.I = I
    def add_I(self, value): self.I.append(value)
    def insert_I(self, index, value): self.I[index] = value
    def export(self, outfile, level, namespace_='', name_='IList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IList'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for I_ in self.I:
            I_.export(outfile, level, namespace_, name_='I', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.I
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('I=[\n')
        level += 1
        for I_ in self.I:
            showIndent(outfile, level)
            outfile.write('model_.I(\n')
            I_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'I':
            obj_ = I.factory()
            obj_.build(child_)
            self.I.append(obj_)
# end class IList


class I(GeneratedsSuper):
    """One specific Information (HIM message) for the current connection.
    It can contain a header of the message, the text body and a
    uniform resource identifier (URI) like a HTML page with detailed
    information."""
    subclass = None
    superclass = None
    def __init__(self, arr=None, lead=None, header=None, dep=None, text=None, symbol=None, altRouteStart=None, uriCustom=None, altRouteEnd=None, locType=None, type_=0, section=None, channel=None):
        self.arr = _cast(None, arr)
        self.lead = _cast(None, lead)
        self.header = _cast(None, header)
        self.dep = _cast(None, dep)
        self.text = _cast(None, text)
        self.symbol = _cast(None, symbol)
        self.altRouteStart = _cast(int, altRouteStart)
        self.uriCustom = _cast(None, uriCustom)
        self.altRouteEnd = _cast(int, altRouteEnd)
        self.locType = _cast(int, locType)
        self.type_ = _cast(int, type_)
        self.section = _cast(int, section)
        self.channel = _cast(int, channel)
        pass
    def factory(*args_, **kwargs_):
        if I.subclass:
            return I.subclass(*args_, **kwargs_)
        else:
            return I(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_arr(self): return self.arr
    def set_arr(self, arr): self.arr = arr
    def get_lead(self): return self.lead
    def set_lead(self, lead): self.lead = lead
    def get_header(self): return self.header
    def set_header(self, header): self.header = header
    def get_dep(self): return self.dep
    def set_dep(self, dep): self.dep = dep
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def get_altRouteStart(self): return self.altRouteStart
    def set_altRouteStart(self, altRouteStart): self.altRouteStart = altRouteStart
    def get_uriCustom(self): return self.uriCustom
    def set_uriCustom(self, uriCustom): self.uriCustom = uriCustom
    def get_altRouteEnd(self): return self.altRouteEnd
    def set_altRouteEnd(self, altRouteEnd): self.altRouteEnd = altRouteEnd
    def get_locType(self): return self.locType
    def set_locType(self, locType): self.locType = locType
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_section(self): return self.section
    def set_section(self, section): self.section = section
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    def export(self, outfile, level, namespace_='', name_='I', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='I')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='I'):
        if self.arr is not None and 'arr' not in already_processed:
            already_processed.append('arr')
            outfile.write(' arr=%s' % (self.gds_format_string(quote_attrib(self.arr).encode(ExternalEncoding), input_name='arr'), ))
        if self.lead is not None and 'lead' not in already_processed:
            already_processed.append('lead')
            outfile.write(' lead=%s' % (self.gds_format_string(quote_attrib(self.lead).encode(ExternalEncoding), input_name='lead'), ))
        if self.header is not None and 'header' not in already_processed:
            already_processed.append('header')
            outfile.write(' header=%s' % (self.gds_format_string(quote_attrib(self.header).encode(ExternalEncoding), input_name='header'), ))
        if self.dep is not None and 'dep' not in already_processed:
            already_processed.append('dep')
            outfile.write(' dep=%s' % (self.gds_format_string(quote_attrib(self.dep).encode(ExternalEncoding), input_name='dep'), ))
        if self.text is not None and 'text' not in already_processed:
            already_processed.append('text')
            outfile.write(' text=%s' % (self.gds_format_string(quote_attrib(self.text).encode(ExternalEncoding), input_name='text'), ))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            outfile.write(' symbol=%s' % (self.gds_format_string(quote_attrib(self.symbol).encode(ExternalEncoding), input_name='symbol'), ))
        if self.altRouteStart is not None and 'altRouteStart' not in already_processed:
            already_processed.append('altRouteStart')
            outfile.write(' altRouteStart="%s"' % self.gds_format_integer(self.altRouteStart, input_name='altRouteStart'))
        if self.uriCustom is not None and 'uriCustom' not in already_processed:
            already_processed.append('uriCustom')
            outfile.write(' uriCustom=%s' % (self.gds_format_string(quote_attrib(self.uriCustom).encode(ExternalEncoding), input_name='uriCustom'), ))
        if self.altRouteEnd is not None and 'altRouteEnd' not in already_processed:
            already_processed.append('altRouteEnd')
            outfile.write(' altRouteEnd="%s"' % self.gds_format_integer(self.altRouteEnd, input_name='altRouteEnd'))
        if self.locType is not None and 'locType' not in already_processed:
            already_processed.append('locType')
            outfile.write(' locType="%s"' % self.gds_format_integer(self.locType, input_name='locType'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type="%s"' % self.gds_format_integer(self.type_, input_name='type'))
        if self.section is not None and 'section' not in already_processed:
            already_processed.append('section')
            outfile.write(' section="%s"' % self.gds_format_integer(self.section, input_name='section'))
        if self.channel is not None and 'channel' not in already_processed:
            already_processed.append('channel')
            outfile.write(' channel="%s"' % self.gds_format_integer(self.channel, input_name='channel'))
    def exportChildren(self, outfile, level, namespace_='', name_='I', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='I'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.arr is not None and 'arr' not in already_processed:
            already_processed.append('arr')
            showIndent(outfile, level)
            outfile.write('arr = "%s",\n' % (self.arr,))
        if self.lead is not None and 'lead' not in already_processed:
            already_processed.append('lead')
            showIndent(outfile, level)
            outfile.write('lead = "%s",\n' % (self.lead,))
        if self.header is not None and 'header' not in already_processed:
            already_processed.append('header')
            showIndent(outfile, level)
            outfile.write('header = "%s",\n' % (self.header,))
        if self.dep is not None and 'dep' not in already_processed:
            already_processed.append('dep')
            showIndent(outfile, level)
            outfile.write('dep = "%s",\n' % (self.dep,))
        if self.text is not None and 'text' not in already_processed:
            already_processed.append('text')
            showIndent(outfile, level)
            outfile.write('text = "%s",\n' % (self.text,))
        if self.symbol is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            showIndent(outfile, level)
            outfile.write('symbol = "%s",\n' % (self.symbol,))
        if self.altRouteStart is not None and 'altRouteStart' not in already_processed:
            already_processed.append('altRouteStart')
            showIndent(outfile, level)
            outfile.write('altRouteStart = %d,\n' % (self.altRouteStart,))
        if self.uriCustom is not None and 'uriCustom' not in already_processed:
            already_processed.append('uriCustom')
            showIndent(outfile, level)
            outfile.write('uriCustom = "%s",\n' % (self.uriCustom,))
        if self.altRouteEnd is not None and 'altRouteEnd' not in already_processed:
            already_processed.append('altRouteEnd')
            showIndent(outfile, level)
            outfile.write('altRouteEnd = %d,\n' % (self.altRouteEnd,))
        if self.locType is not None and 'locType' not in already_processed:
            already_processed.append('locType')
            showIndent(outfile, level)
            outfile.write('locType = %d,\n' % (self.locType,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %d,\n' % (self.type_,))
        if self.section is not None and 'section' not in already_processed:
            already_processed.append('section')
            showIndent(outfile, level)
            outfile.write('section = %d,\n' % (self.section,))
        if self.channel is not None and 'channel' not in already_processed:
            already_processed.append('channel')
            showIndent(outfile, level)
            outfile.write('channel = %d,\n' % (self.channel,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('arr', node)
        if value is not None and 'arr' not in already_processed:
            already_processed.append('arr')
            self.arr = value
        value = find_attr_value_('lead', node)
        if value is not None and 'lead' not in already_processed:
            already_processed.append('lead')
            self.lead = value
        value = find_attr_value_('header', node)
        if value is not None and 'header' not in already_processed:
            already_processed.append('header')
            self.header = value
        value = find_attr_value_('dep', node)
        if value is not None and 'dep' not in already_processed:
            already_processed.append('dep')
            self.dep = value
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.append('text')
            self.text = value
        value = find_attr_value_('symbol', node)
        if value is not None and 'symbol' not in already_processed:
            already_processed.append('symbol')
            self.symbol = value
        value = find_attr_value_('altRouteStart', node)
        if value is not None and 'altRouteStart' not in already_processed:
            already_processed.append('altRouteStart')
            try:
                self.altRouteStart = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('uriCustom', node)
        if value is not None and 'uriCustom' not in already_processed:
            already_processed.append('uriCustom')
            self.uriCustom = value
        value = find_attr_value_('altRouteEnd', node)
        if value is not None and 'altRouteEnd' not in already_processed:
            already_processed.append('altRouteEnd')
            try:
                self.altRouteEnd = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('locType', node)
        if value is not None and 'locType' not in already_processed:
            already_processed.append('locType')
            try:
                self.locType = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            try:
                self.type_ = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('section', node)
        if value is not None and 'section' not in already_processed:
            already_processed.append('section')
            try:
                self.section = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('channel', node)
        if value is not None and 'channel' not in already_processed:
            already_processed.append('channel')
            try:
                self.channel = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class I


class DateBeginType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Date=None):
        self.Date = Date
    def factory(*args_, **kwargs_):
        if DateBeginType.subclass:
            return DateBeginType.subclass(*args_, **kwargs_)
        else:
            return DateBeginType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def export(self, outfile, level, namespace_='', name_='DateBeginType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateBeginType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateBeginType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateBeginType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.Date).encode(ExternalEncoding), input_name='Date'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Date is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DateBeginType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=%s,\n' % quote_python(self.Date).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
# end class DateBeginType


class DateEndType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Date=None):
        self.Date = Date
    def factory(*args_, **kwargs_):
        if DateEndType.subclass:
            return DateEndType.subclass(*args_, **kwargs_)
        else:
            return DateEndType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def export(self, outfile, level, namespace_='', name_='DateEndType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateEndType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateEndType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateEndType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_string(quote_xml(self.Date).encode(ExternalEncoding), input_name='Date'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Date is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DateEndType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=%s,\n' % quote_python(self.Date).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Date':
            Date_ = child_.text
            Date_ = self.gds_validate_string(Date_, node, 'Date')
            self.Date = Date_
# end class DateEndType


class ServiceDaysListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ServiceDays=None):
        self.ServiceDays = ServiceDays
    def factory(*args_, **kwargs_):
        if ServiceDaysListType.subclass:
            return ServiceDaysListType.subclass(*args_, **kwargs_)
        else:
            return ServiceDaysListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceDays(self): return self.ServiceDays
    def set_ServiceDays(self, ServiceDays): self.ServiceDays = ServiceDays
    def export(self, outfile, level, namespace_='', name_='ServiceDaysListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceDaysListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceDaysListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceDaysListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ServiceDays is not None:
            self.ServiceDays.export(outfile, level, namespace_, name_='ServiceDays', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.ServiceDays is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ServiceDaysListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ServiceDays is not None:
            showIndent(outfile, level)
            outfile.write('ServiceDays=model_.ServiceDays(\n')
            self.ServiceDays.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceDays':
            obj_ = ServiceDays.factory()
            obj_.build(child_)
            self.set_ServiceDays(obj_)
# end class ServiceDaysListType


class StopPrognosisType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Arr=None, Dep=None, Status=None, FreeTextL=None):
        self.Arr = Arr
        self.Dep = Dep
        self.Status = Status
        self.FreeTextL = FreeTextL
    def factory(*args_, **kwargs_):
        if StopPrognosisType.subclass:
            return StopPrognosisType.subclass(*args_, **kwargs_)
        else:
            return StopPrognosisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Arr(self): return self.Arr
    def set_Arr(self, Arr): self.Arr = Arr
    def get_Dep(self): return self.Dep
    def set_Dep(self, Dep): self.Dep = Dep
    def get_Status(self): return self.Status
    def set_Status(self, Status): self.Status = Status
    def get_FreeTextL(self): return self.FreeTextL
    def set_FreeTextL(self, FreeTextL): self.FreeTextL = FreeTextL
    def export(self, outfile, level, namespace_='', name_='StopPrognosisType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StopPrognosisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StopPrognosisType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StopPrognosisType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Arr is not None:
            self.Arr.export(outfile, level, namespace_, name_='Arr', pretty_print=pretty_print)
        if self.Dep is not None:
            self.Dep.export(outfile, level, namespace_, name_='Dep', pretty_print=pretty_print)
        if self.Status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStatus>%s</%sStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.Status).encode(ExternalEncoding), input_name='Status'), namespace_, eol_))
        if self.FreeTextL is not None:
            self.FreeTextL.export(outfile, level, namespace_, name_='FreeTextL', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Arr is not None or
            self.Dep is not None or
            self.Status is not None or
            self.FreeTextL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StopPrognosisType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Arr is not None:
            showIndent(outfile, level)
            outfile.write('Arr=model_.Arr(\n')
            self.Arr.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dep is not None:
            showIndent(outfile, level)
            outfile.write('Dep=model_.Dep(\n')
            self.Dep.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Status is not None:
            showIndent(outfile, level)
            outfile.write('Status=%s,\n' % quote_python(self.Status).encode(ExternalEncoding))
        if self.FreeTextL is not None:
            showIndent(outfile, level)
            outfile.write('FreeTextL=model_.FreeTextLType(\n')
            self.FreeTextL.exportLiteral(outfile, level, name_='FreeTextL')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Arr':
            obj_ = ArrDepType.factory()
            obj_.build(child_)
            self.set_Arr(obj_)
        elif nodeName_ == 'Dep':
            obj_ = ArrDepType.factory()
            obj_.build(child_)
            self.set_Dep(obj_)
        elif nodeName_ == 'Status':
            Status_ = child_.text
            Status_ = self.gds_validate_string(Status_, node, 'Status')
            self.Status = Status_
        elif nodeName_ == 'FreeTextL':
            obj_ = FreeTextLType.factory()
            obj_.build(child_)
            self.set_FreeTextL(obj_)
# end class StopPrognosisType


class Status(GeneratedsSuper):
    """Realtime status; Possible values are: SCHEDULED: the stop will be
    used as planned (i. e. but it's possible that a delay exists);
    NEW: the stop has been added; PARTIAL_FAILURE: Stop has been
    completely removed from the ride - i.e. no boarding and no exit
    is allowed; FAILURE_AT_ARRIVAL: No exit is allowed;
    FAILURE_AT_DEPARTURE: No boarding is allowed"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Status.subclass:
            return Status.subclass(*args_, **kwargs_)
        else:
            return Status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Status', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Status')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Status'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Status', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Status'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Status


class FreeTextLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Freetext=None):
        self.Freetext = Freetext
    def factory(*args_, **kwargs_):
        if FreeTextLType.subclass:
            return FreeTextLType.subclass(*args_, **kwargs_)
        else:
            return FreeTextLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Freetext(self): return self.Freetext
    def set_Freetext(self, Freetext): self.Freetext = Freetext
    def export(self, outfile, level, namespace_='', name_='FreeTextLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreeTextLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FreeTextLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FreeTextLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Freetext is not None:
            self.Freetext.export(outfile, level, namespace_, name_='Freetext', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Freetext is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FreeTextLType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Freetext is not None:
            showIndent(outfile, level)
            outfile.write('Freetext=model_.FreetextType(\n')
            self.Freetext.exportLiteral(outfile, level, name_='Freetext')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Freetext':
            obj_ = FreetextType.factory()
            obj_.build(child_)
            self.set_Freetext(obj_)
# end class FreeTextLType


class FreetextType(GeneratedsSuper):
    """ARR: only to be displayed, if the arrival delay is displayed. DEP:
    only to be displayed, if the departure delay is displayed. BOTH
    The Freetext is valid for Aiirval delays and departure delays"""
    subclass = None
    superclass = None
    def __init__(self, validFor=None, Text=None, Code=None):
        self.validFor = _cast(None, validFor)
        self.Text = Text
        self.Code = Code
    def factory(*args_, **kwargs_):
        if FreetextType.subclass:
            return FreetextType.subclass(*args_, **kwargs_)
        else:
            return FreetextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def get_validFor(self): return self.validFor
    def set_validFor(self, validFor): self.validFor = validFor
    def export(self, outfile, level, namespace_='', name_='FreetextType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FreetextType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FreetextType'):
        if self.validFor is not None and 'validFor' not in already_processed:
            already_processed.append('validFor')
            outfile.write(' validFor=%s' % (self.gds_format_string(quote_attrib(self.validFor).encode(ExternalEncoding), input_name='validFor'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FreetextType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Text is not None:
            self.Text.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
        if self.Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCode>%s</%sCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.Code).encode(ExternalEncoding), input_name='Code'), namespace_, eol_))
    def hasContent_(self):
        if (
            self.Text is not None or
            self.Code is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FreetextType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.validFor is not None and 'validFor' not in already_processed:
            already_processed.append('validFor')
            showIndent(outfile, level)
            outfile.write('validFor = "%s",\n' % (self.validFor,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Text is not None:
            showIndent(outfile, level)
            outfile.write('Text=model_.Text(\n')
            self.Text.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Code is not None:
            showIndent(outfile, level)
            outfile.write('Code=%s,\n' % quote_python(self.Code).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('validFor', node)
        if value is not None and 'validFor' not in already_processed:
            already_processed.append('validFor')
            self.validFor = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = Text.factory()
            obj_.build(child_)
            self.set_Text(obj_)
        elif nodeName_ == 'Code':
            Code_ = child_.text
            Code_ = self.gds_validate_string(Code_, node, 'Code')
            self.Code = Code_
# end class FreetextType


class Code(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Code.subclass:
            return Code.subclass(*args_, **kwargs_)
        else:
            return Code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='Code', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Code')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Code'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Code', fromsubclass_=False, pretty_print=True):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Code'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Code


class StartViaType(RequestLocationType):
    subclass = None
    superclass = RequestLocationType
    def __init__(self, min=None, Address=None, Poi=None, Station=None, Coord=None, Prod=None):
        super(StartViaType, self).__init__(min, Address, Poi, Station, Coord, )
        self.Prod = Prod
    def factory(*args_, **kwargs_):
        if StartViaType.subclass:
            return StartViaType.subclass(*args_, **kwargs_)
        else:
            return StartViaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Prod(self): return self.Prod
    def set_Prod(self, Prod): self.Prod = Prod
    def export(self, outfile, level, namespace_='', name_='StartViaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StartViaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StartViaType'):
        super(StartViaType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StartViaType')
    def exportChildren(self, outfile, level, namespace_='', name_='StartViaType', fromsubclass_=False, pretty_print=True):
        super(StartViaType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Prod is not None:
            self.Prod.export(outfile, level, namespace_, name_='Prod', pretty_print=pretty_print)
    def hasContent_(self):
        if (
            self.Prod is not None or
            super(StartViaType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StartViaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StartViaType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StartViaType, self).exportLiteralChildren(outfile, level, name_)
        if self.Prod is not None:
            showIndent(outfile, level)
            outfile.write('Prod=model_.Prod(\n')
            self.Prod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(StartViaType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Prod':
            obj_ = Prod.factory()
            obj_.build(child_)
            self.set_Prod(obj_)
        super(StartViaType, self).buildChildren(child_, node, nodeName_, True)
# end class StartViaType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReqC'
        rootClass = ReqC
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReqC'
        rootClass = ReqC
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="ReqC",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ReqC'
        rootClass = ReqC
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from hafas_api import *\n\n')
    sys.stdout.write('import hafas_api as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AltConList",
    "AnnoText",
    "ArrDepType",
    "Arrival",
    "Attribute",
    "AttributeVariant",
    "Back",
    "BasicStop",
    "Code",
    "Comment",
    "CommentList",
    "ConBasicReq",
    "ConReq",
    "ConRes",
    "ConResCtxt",
    "ConScrReq",
    "ConSection",
    "ConSectionList",
    "Connection",
    "ConnectionList",
    "ContextURL",
    "DateBeginType",
    "DateEndType",
    "Departure",
    "Distance",
    "Err",
    "FreeTextLType",
    "FreetextType",
    "FromText",
    "Front",
    "GISParameters",
    "GisRoute",
    "I",
    "IList",
    "IndividualTransport",
    "IrregularServiceText",
    "JHandle",
    "JProg",
    "JStatus",
    "Journey",
    "JourneyAttribute",
    "JourneyAttributeList",
    "JourneyList",
    "LocationType",
    "MainStop",
    "NamedValue",
    "Now",
    "Overview",
    "ParameterList",
    "PassList",
    "Period",
    "Platform",
    "Price",
    "Pricing",
    "PricingList",
    "PricingResult",
    "PricingSet",
    "Prod",
    "Product",
    "ProductFilter",
    "Products",
    "RFlags",
    "RegularServiceText",
    "ReqC",
    "ReqTType",
    "RequestLocationType",
    "ResC",
    "RtState",
    "RtStateList",
    "STBJourney",
    "STBReq",
    "STBRes",
    "ServiceDays",
    "ServiceDaysListType",
    "StartViaType",
    "StationType",
    "Status",
    "StopPrognosisType",
    "Tariff",
    "Text",
    "Ticket",
    "Time",
    "TimeType",
    "Timetable",
    "ToText",
    "Today",
    "Total",
    "TrainFilter",
    "Transfer",
    "Traveller",
    "TravellerCategory",
    "ViaType",
    "Walk"
    ]
